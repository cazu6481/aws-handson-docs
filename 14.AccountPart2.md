## **AWSアカウント・権限設計（基本方針）**

目次

[**概要**](#%E6%A6%82%E8%A6%81)

[**権限設計の基本原則**](#1-%E6%A8%A9%E9%99%90%E8%A8%AD%E8%A8%88%)

[**IAM Identity
Center統合戦略**](#2-iam-identity-center%E7%B5%B1%E5%90%88)

[**職務分離と最小権限の実装**](#3-%E8%81%B7%E5%8B%99%E5%88%86%E9%9B%A2%)

[**クロスアカウント権限管理**](#4-%E3%82%AF%E3%83%AD%E3%82%B9%E3%82%A2%)

[**コンプライアンス・監査対応**](#5-%E3%82%B3%E3%83%B3%E3%83%97%E3%83%A9%)

[**セキュリティ境界設計**](#6-%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%)

[**緊急時アクセス管理**](#7-%E7%B7%8A%E6%80%A5%E6%99%82%E3%82%A2%)

[**監視・ログ戦略**](#8-%E7%9B%A3%E8%A6%96%E3%83%AD%E3%82%B0%)

[**実装ガイドライン**](#9-%E5%AE%9F%E8%A3%85%E3%82%AC%E3%82%A4%)

概要

設計背景

TechNova社の120アカウント構成における権限管理は、事業部門別アカウント構成と密接に連携し、セキュリティとガバナンスを両立させる必要があります。本方針書は、物理的なアカウント分離に対する論理的な権限管理戦略を定義します。

アカウント構成との整合性

事業部門別アカウント構成で定義された以下の構造に対応：

管理系アカウント: セキュリティ、ログ、ネットワーク、請求管理

事業部門アカウント: 製品開発、マーケティング、データ分析、HR

環境分離: 本番(prod)、ステージング(staging)、開発(dev)

特殊用途アカウント: サンドボックス、共有サービス

権限設計の目標

Zero Trust アーキテクチャの実現

最小権限原則の徹底

職務分離による不正防止

コンプライアンス要件への準拠

運用効率の向上

1\. 権限設計の基本原則

1.1 ゼロトラストセキュリティモデル

yaml

*\# Zero Trust の実装原則*

zero_trust_principles:

identity_verification:

\- "全てのアクセスを認証・認可"

\- "アカウント境界での検証強化"

\- "継続的な信頼度評価"

least_privilege:

\- "最小限の権限のみ付与"

\- "時間制限付きアクセス"

\- "Just-In-Time権限昇格"

assume_breach:

\- "侵害を前提とした設計"

\- "横展開の防止"

\- "異常検知と自動対応"

1.2 権限管理階層

┌─────────────────────────────────────────────────────────────┐

│ Organization Level │

│ ┌─────────────────┐ ┌─────────────────┐ ┌──────────────┐ │

│ │ Identity │ │ Compliance │ │ Audit │ │

│ │ Management │ │ Governance │ │ Logging │ │

│ └─────────────────┘ └─────────────────┘ └──────────────┘ │

└─────────────────────────────────────────────────────────────┘

│

┌─────────────────────────────────────────────────────────────┐

│ Business Unit Level │

│ ┌─────────────────┐ ┌─────────────────┐ ┌──────────────┐ │

│ │ Department │ │ Project │ │ Resource │ │

│ │ Admin │ │ Teams │ │ Access │ │

│ └─────────────────┘ └─────────────────┘ └──────────────┘ │

└─────────────────────────────────────────────────────────────┘

│

┌─────────────────────────────────────────────────────────────┐

│ Application Level │

│ ┌─────────────────┐ ┌─────────────────┐ ┌──────────────┐ │

│ │ Service │ │ Environment │ │ Resource │ │

│ │ Accounts │ │ Isolation │ │ Specific │ │

│ └─────────────────┘ └─────────────────┘ └──────────────┘ │

└─────────────────────────────────────────────────────────────┘

1.3 権限付与の原則

最小権限原則 (Principle of Least Privilege)

json

{

"minimum_required_access": {

"default_policy": "DENY_ALL",

"explicit_grants": "SPECIFIC_RESOURCES_ONLY",

"time_bounds": "LIMITED_DURATION",

"scope_bounds": "NARROWEST_POSSIBLE"

},

"progressive_access": {

"initial_access": "READ_ONLY",

"proven_need": "ADDITIONAL_PERMISSIONS",

"regular_review": "ACCESS_CERTIFICATION"

}

}

職務分離原則 (Separation of Duties)

yaml

separation_of_duties:

development_vs_production:

\- "開発者は本番環境への直接アクセス不可"

\- "本番変更は承認プロセス必須"

\- "緊急時のみ例外的な直接アクセス"

security_vs_operations:

\- "セキュリティ設定は専門チームのみ"

\- "運用チームは日常管理のみ"

\- "相互監視による不正防止"

audit_independence:

\- "監査ログは独立アカウントで管理"

\- "監査担当者は被監査システムにアクセス不可"

\- "ログの改ざん防止機能"

2\. IAM Identity Center統合戦略

2.1 アーキテクチャ概要

hcl

*\# IAM Identity Center の組織レベル設定*

resource "aws_ssoadmin_instances" "main" {

*\# Organization の管理アカウントで設定*

}

*\# 外部IDプロバイダー統合*

resource "aws_ssoadmin_instance_access_control_attributes" "main" {

instance_arn = aws_ssoadmin_instances.main.arn

attribute {

key = "Department"

value {

source = \["\${path:enterprise.department}"\]

}

}

attribute {

key = "CostCenter"

value {

source = \["\${path:enterprise.costCenter}"\]

}

}

attribute {

key = "JobTitle"

value {

source = \["\${path:enterprise.title}"\]

}

}

}

2.2 Permission Set 設計戦略

基本Permission Set階層

yaml

permission_sets:

*\# 管理系権限*

administrative:

OrganizationAdministrator:

description: "組織全体の管理権限"

accounts: \["management-\*"\]

policies: \["AdministratorAccess"\]

conditions:

mfa_required: true

session_duration: "2hours"

SecurityAdministrator:

description: "セキュリティ設定管理"

accounts: \["security-\*", "audit-\*"\]

policies: \["SecurityAudit", "CustomSecurityAdmin"\]

conditions:

ip_restriction: "office_networks"

mfa_required: true

*\# 事業部門権限*

business_units:

ProductDeveloper:

description: "製品開発チーム"

accounts: \["product-dev-\*", "product-staging-\*"\]

policies: \["EC2FullAccess", "S3Developer", "RDSReadAccess"\]

conditions:

time_restriction: "business_hours"

ProductionSupport:

description: "本番環境監視・サポート"

accounts: \["product-prod-\*"\]

policies: \["CloudWatchReadOnly", "LimitedEC2Access"\]

conditions:

approval_required: true

max_session_duration: "4hours"

*\# 環境別権限*

environment_specific:

DevelopmentFullAccess:

description: "開発環境フルアクセス"

accounts: \["\*-dev-\*"\]

policies: \["PowerUserAccess"\]

ProductionReadOnly:

description: "本番環境読み取り専用"

accounts: \["\*-prod-\*"\]

policies: \["ReadOnlyAccess", "SupportUser"\]

2.3 属性ベースアクセス制御 (ABAC)

json

{

"abac_policy_template": {

"Version": "2012-10-17",

"Statement": \[

{

"Effect": "Allow",

"Action": "\*",

"Resource": "\*",

"Condition": {

"StringEquals": {

"aws:PrincipalTag/Department": "\${aws:RequestedRegion}",

"ec2:ResourceTag/Environment": "\${saml:Environment}",

"s3:ResourceTag/CostCenter": "\${saml:CostCenter}"

},

"DateGreaterThan": {

"aws:CurrentTime": "\${saml:SessionStart}"

},

"DateLessThan": {

"aws:CurrentTime": "\${saml:SessionEnd}"

}

}

}

\]

}

}

2.4 外部IDプロバイダー統合

hcl

*\# Active Directory統合*

resource "aws_ssoadmin_external_identity_provider_configuration"
"ad_integration" {

instance_arn = aws_ssoadmin_instances.main.arn

identity_provider_configuration {

external_identity_provider_type = "SAML"

saml_provider_configuration {

metadata_document =
file("\${path.module}/saml/technova-ad-metadata.xml")

}

}

}

*\# Google Workspace統合 (将来対応)*

resource "aws_ssoadmin_external_identity_provider_configuration"
"google_workspace" {

instance_arn = aws_ssoadmin_instances.main.arn

identity_provider_configuration {

external_identity_provider_type = "OIDC"

oidc_provider_configuration {

issuer_url = "https://accounts.google.com"

authorization_endpoint = "https://accounts.google.com/o/oauth2/v2/auth"

token_endpoint = "https://oauth2.googleapis.com/token"

userinfo_endpoint = "https://openidconnect.googleapis.com/v1/userinfo"

jwks_uri = "https://www.googleapis.com/oauth2/v3/certs"

client_id = var.google_workspace_client_id

client_secret = var.google_workspace_client_secret

}

}

}

3\. 職務分離と最小権限の実装

3.1 職務分離マトリックス

yaml

role_separation_matrix:

*\# 開発チーム*

developers:

allowed_environments: \["dev", "staging"\]

forbidden_environments: \["prod"\]

allowed_actions:

\- "ec2:\*"

\- "s3:GetObject\*"

\- "s3:PutObject\*"

\- "rds:Describe\*"

forbidden_actions:

\- "iam:\*"

\- "organizations:\*"

\- "account:\*"

*\# インフラチーム*

infrastructure:

allowed_environments: \["dev", "staging", "prod"\]

allowed_actions:

\- "ec2:\*"

\- "vpc:\*"

\- "route53:\*"

approval_required:

\- "iam:CreateRole"

\- "iam:AttachRolePolicy"

forbidden_actions:

\- "organizations:\*"

\- "account:CloseAccount"

*\# セキュリティチーム*

security:

allowed_environments: \["all"\]

allowed_actions:

\- "iam:\*"

\- "organizations:\*"

\- "guardduty:\*"

\- "securityhub:\*"

read_only_access:

\- "logs:\*"

\- "cloudtrail:\*"

3.2 最小権限ポリシー実装

カスタムポリシーテンプレート

json

{

"Version": "2012-10-17",

"Statement": \[

{

"Sid": "DeveloperBaseAccess",

"Effect": "Allow",

"Action": \[

"ec2:Describe\*",

"ec2:List\*",

"s3:GetObject",

"s3:PutObject"

\],

"Resource": "\*",

"Condition": {

"StringEquals": {

"aws:RequestedRegion": \["ap-northeast-1", "us-east-1"\],

"ec2:ResourceTag/Environment": \["dev", "staging"\]

},

"IpAddress": {

"aws:SourceIp": \[

"10.0.0.0/8",

"172.16.0.0/12"

\]

}

}

},

{

"Sid": "DenyProductionAccess",

"Effect": "Deny",

"Action": "\*",

"Resource": "\*",

"Condition": {

"StringEquals": {

"ec2:ResourceTag/Environment": "prod"

}

}

}

\]

}

動的権限制御

hcl

*\# タグベースのリソースアクセス制御*

resource "aws_iam_policy" "tag_based_access" {

name = "TagBasedResourceAccess"

policy = jsonencode({

Version = "2012-10-17"

Statement = \[

{

Effect = "Allow"

Action = \[

"ec2:StartInstances",

"ec2:StopInstances",

"ec2:RebootInstances"

\]

Resource = "\*"

Condition = {

StringEquals = {

"ec2:ResourceTag/Owner" = "\$\${saml:userid}"

"ec2:ResourceTag/Department" = "\$\${saml:department}"

}

}

}

\]

})

}

*\# 時間制限付きアクセス*

resource "aws_iam_policy" "time_based_access" {

name = "TimeBasedAccess"

policy = jsonencode({

Version = "2012-10-17"

Statement = \[

{

Effect = "Allow"

Action = "\*"

Resource = "\*"

Condition = {

DateGreaterThan = {

"aws:CurrentTime" = "08:00Z"

}

DateLessThan = {

"aws:CurrentTime" = "18:00Z"

}

StringEquals = {

"aws:RequestedRegion" = \["ap-northeast-1"\]

}

}

}

\]

})

}

3.3 Just-In-Time (JIT) アクセス管理

python

*\# JITアクセス管理Lambda関数*

import boto3

import json

from datetime import datetime, timedelta

def lambda_handler(event, context):

"""

Just-In-Time権限昇格リクエスト処理

"""

try:

*\# リクエスト情報の取得*

user_id = event\['user_id'\]

requested_permissions = event\['permissions'\]

business_justification = event\['justification'\]

duration_hours = event.get('duration', 2) *\# デフォルト2時間*

*\# 承認プロセス*

approval_result = process_approval_workflow(

user_id, requested_permissions, business_justification

)

if approval_result\['approved'\]:

*\# 一時的な権限の付与*

temp_role_arn = create_temporary_role(

user_id, requested_permissions, duration_hours

)

*\# 自動削除の予約*

schedule_role_deletion(temp_role_arn, duration_hours)

return {

'statusCode': 200,

'body': json.dumps({

'status': 'approved',

'temporary_role_arn': temp_role_arn,

'expires_at': (datetime.now() +
timedelta(hours=duration_hours)).isoformat(),

'instructions': 'aws sts assume-role --role-arn ' + temp_role_arn

})

}

else:

return {

'statusCode': 403,

'body': json.dumps({

'status': 'denied',

'reason': approval_result\['reason'\]

})

}

except Exception as e:

return {

'statusCode': 500,

'body': json.dumps({'error': str(e)})

}

def process_approval_workflow(user_id, permissions, justification):

"""

承認ワークフローの処理

"""

*\# リスクレベルの評価*

risk_level = evaluate_risk_level(permissions)

if risk_level == 'LOW':

*\# 自動承認*

return {'approved': True, 'reason': 'Auto-approved: Low risk'}

elif risk_level == 'MEDIUM':

*\# マネージャー承認が必要*

return initiate_manager_approval(user_id, justification)

else:

*\# 複数レベルの承認が必要*

return initiate_multi_level_approval(user_id, justification)

def create_temporary_role(user_id, permissions, duration_hours):

"""

一時的なIAMロールの作成

"""

iam = boto3.client('iam')

*\# ロール名の生成*

role_name = f"TempAccess-{user_id}-{int(datetime.now().timestamp())}"

*\# 信頼ポリシー*

assume_role_policy = {

"Version": "2012-10-17",

"Statement": \[

{

"Effect": "Allow",

"Principal": {"AWS":
f"arn:aws:iam::{boto3.client('sts').get_caller_identity()\['Account'\]}:user/{user_id}"},

"Action": "sts:AssumeRole",

"Condition": {

"StringEquals": {

"sts:ExternalId": generate_external_id(user_id)

}

}

}

\]

}

*\# ロール作成*

response = iam.create_role(

RoleName=role_name,

AssumeRolePolicyDocument=json.dumps(assume_role_policy),

Description=f"Temporary elevated access for {user_id}",

MaxSessionDuration=duration_hours \* 3600,

Tags=\[

{'Key': 'Purpose', 'Value': 'JIT-Access'},

{'Key': 'User', 'Value': user_id},

{'Key': 'ExpiresAt', 'Value': (datetime.now() +
timedelta(hours=duration_hours)).isoformat()}

\]

)

*\# 権限の付与*

for permission in permissions:

iam.attach_role_policy(

RoleName=role_name,

PolicyArn=permission\['policy_arn'\]

)

return response\['Role'\]\['Arn'\]

4\. クロスアカウント権限管理

4.1 信頼関係設計

yaml

cross_account_trust_model:

*\# 管理アカウント → 全アカウント*

management_account:

trust_direction: "outbound"

trusted_accounts: \["all_organization_accounts"\]

permitted_roles:

\- "OrganizationAccountAccessRole"

\- "SecurityAuditRole"

conditions:

\- "mfa_required: true"

\- "source_ip_restriction: office_networks"

*\# セキュリティアカウント → 全アカウント（読み取り専用）*

security_account:

trust_direction: "outbound"

trusted_accounts: \["all_organization_accounts"\]

permitted_roles:

\- "SecurityAuditRole"

permissions: \["read_only", "security_findings"\]

*\# ログアカウント → 全アカウント（ログ収集）*

logging_account:

trust_direction: "inbound"

trusting_accounts: \["all_organization_accounts"\]

permitted_actions:

\- "logs:CreateLogGroup"

\- "logs:CreateLogStream"

\- "logs:PutLogEvents"

4.2 クロスアカウントロールの実装

hcl

*\# 組織レベルでのクロスアカウントロール*

resource "aws_iam_role" "cross_account_security_audit" {

for_each = toset(var.organization_account_ids)

name = "CrossAccountSecurityAudit"

assume_role_policy = jsonencode({

Version = "2012-10-17"

Statement = \[

{

Effect = "Allow"

Principal = {

AWS = "arn:aws:iam::\${var.security_account_id}:root"

}

Action = "sts:AssumeRole"

Condition = {

StringEquals = {

"sts:ExternalId" = var.cross_account_external_id

}

Bool = {

"aws:MultiFactorAuthPresent" = "true"

}

IpAddress = {

"aws:SourceIp" = var.allowed_ip_ranges

}

}

}

\]

})

tags = {

Purpose = "Cross-Account Security Audit"

ManagedBy = "Terraform"

}

}

*\# セキュリティ監査用の統一ポリシー*

resource "aws_iam_role_policy_attachment" "security_audit_policy" {

for_each = toset(var.organization_account_ids)

role = aws_iam_role.cross_account_security_audit\[each.key\].name

policy_arn = "arn:aws:iam::aws:policy/SecurityAudit"

}

*\# カスタムセキュリティポリシー*

resource "aws_iam_role_policy" "custom_security_audit" {

for_each = toset(var.organization_account_ids)

name = "CustomSecurityAuditPolicy"

role = aws_iam_role.cross_account_security_audit\[each.key\].id

policy = jsonencode({

Version = "2012-10-17"

Statement = \[

{

Effect = "Allow"

Action = \[

"access-analyzer:List\*",

"access-analyzer:Get\*",

"guardduty:List\*",

"guardduty:Get\*",

"securityhub:List\*",

"securityhub:Get\*",

"config:List\*",

"config:Get\*",

"config:Describe\*"

\]

Resource = "\*"

},

{

Effect = "Allow"

Action = \[

"s3:GetBucketPolicy",

"s3:GetBucketAcl",

"s3:GetBucketPublicAccessBlock"

\]

Resource = "\*"

}

\]

})

}

4.3 アカウント間通信制御

hcl

*\# VPC エンドポイントポリシー（アカウント間制限）*

resource "aws_vpc_endpoint_policy" "s3_cross_account_policy" {

vpc_endpoint_id = aws_vpc_endpoint.s3.id

policy = jsonencode({

Version = "2012-10-17"

Statement = \[

{

Effect = "Allow"

Principal = "\*"

Action = \[

"s3:GetObject",

"s3:PutObject"

\]

Resource = "\*"

Condition = {

StringEquals = {

"aws:PrincipalAccount" = var.trusted_account_ids

}

}

},

{

Effect = "Deny"

Principal = "\*"

Action = "\*"

Resource = "\*"

Condition = {

StringNotEquals = {

"aws:PrincipalAccount" = var.trusted_account_ids

}

}

}

\]

})

}

*\# リソースベースポリシー例（S3バケット）*

resource "aws_s3_bucket_policy" "cross_account_access" {

bucket = aws_s3_bucket.shared_resources.id

policy = jsonencode({

Version = "2012-10-17"

Statement = \[

{

Sid = "CrossAccountAccess"

Effect = "Allow"

Principal = {

AWS = \[

for account_id in var.trusted_account_ids :

"arn:aws:iam::\${account_id}:root"

\]

}

Action = \[

"s3:GetObject",

"s3:PutObject"

\]

Resource = "\${aws_s3_bucket.shared_resources.arn}/\*"

Condition = {

StringEquals = {

"s3:x-amz-server-side-encryption" = "aws:kms"

}

Bool = {

"aws:SecureTransport" = "true"

}

}

}

\]

})

}

5\. コンプライアンス・監査対応

5.1 法的要件への対応

yaml

compliance_frameworks:

*\# SOC 2 Type II*

soc2_type2:

requirements:

\- "アクセス制御の文書化"

\- "権限変更の承認プロセス"

\- "定期的なアクセスレビュー"

\- "特権アクセスの監視"

implementation:

access_control_documentation: "IAM Policy文書化"

approval_process: "ServiceNow統合ワークフロー"

periodic_review: "四半期アクセス認証"

privileged_monitoring: "CloudTrail + GuardDuty"

*\# ISO 27001*

iso27001:

requirements:

\- "情報セキュリティ管理システム(ISMS)"

\- "リスクアセスメントとリスク処理"

\- "アクセス管理"

\- "暗号化"

implementation:

isms: "AWS Config Rules + Security Hub"

risk_assessment: "AWS Well-Architected Framework"

access_management: "IAM Identity Center + Access Analyzer"

encryption: "KMS + CloudTrail暗号化"

*\# PCI DSS (カード決済関連)*

pci_dss:

scope: "決済処理アカウント"

requirements:

\- "カード会員データへのアクセス制限"

\- "一意のユーザーIDの割り当て"

\- "物理的・論理的アクセスの制限"

\- "ネットワークリソースとCADへのアクセス監視"

implementation:

data_access_restriction: "専用VPC + セキュリティグループ"

unique_user_id: "IAM Identity Center強制"

access_restriction: "MFA + IP制限"

monitoring: "VPC Flow Logs + GuardDuty"

5.2 コンプライアンス

hcl

*\# AWS Config Rules for コンプライアンス監視*

resource "aws_config_configuration_recorder" "compliance_recorder" {

name = "TechNovaComplianceRecorder"

role_arn = aws_iam_role.config_role.arn

recording_group {

all_supported = true

include_global_resource_types = true

}

}

*\# SOC 2コンプライアンス用Config Rules*

resource "aws_config_config_rule" "soc2_mfa_enabled" {

name = "soc2-mfa-enabled-for-console-access"

source {

owner = "AWS"

source_identifier = "MFA_ENABLED_FOR_ROOT"

}

depends_on = \[aws_config_configuration_recorder.compliance_recorder\]

}

resource "aws_config_config_rule" "soc2_password_policy" {

name = "soc2-iam-password-policy"

source {

owner = "AWS"

source_identifier = "IAM_PASSWORD_POLICY"

}

input_parameters = jsonencode({

RequireUppercaseCharacters = "true"

RequireLowercaseCharacters = "true"

RequireSymbols = "true"

RequireNumbers = "true"

MinimumPasswordLength = "14"

PasswordReusePrevention = "12"

MaxPasswordAge = "90"

})

}

*\# ISO 27001コンプライアンス用Rules*

resource "aws_config_config_rule" "iso27001_encryption_at_rest" {

name = "iso27001-s3-bucket-server-side-encryption-enabled"

source {

owner = "AWS"

source_identifier = "S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED"

}

}

*\# PCI DSSコンプライアンス用Rules（決済処理アカウント）*

resource "aws_config_config_rule" "pci_dss_security_groups" {

count = contains(var.pci_scope_accounts,
data.aws_caller_identity.current.account_id) ? 1 : 0

name = "pci-dss-security-groups-restricted"

source {

owner = "AWS"

再試行

C

続ける

編集

owner = "AWS" source_identifier = "INCOMING_SSH_DISABLED" } }

resource "aws_config_config_rule" "pci_dss_root_access_key" { count =
contains(var.pci_scope_accounts,
data.aws_caller_identity.current.account_id) ? 1 : 0

name = "pci-dss-root-access-key-check"

source { owner = "AWS" source_identifier = "ROOT_ACCESS_KEY_CHECK" } }

\### 5.3 監査証跡の設計

\`\`\`hcl

\# 組織レベルのCloudTrail設定

resource "aws_cloudtrail" "organization_trail" {

name = "TechNova-Organization-AuditTrail"

s3_bucket_name = aws_s3_bucket.audit_logs.bucket

\# 組織全体のイベントを記録

is_organization_trail = true

is_multi_region_trail = true

\# データイベントの記録

event_selector {

read_write_type = "All"

include_management_events = true

exclude_management_event_sources = \[\]

data_resource {

type = "AWS::S3::Object"

values = \["arn:aws:s3:::\*/sensitive-data/\*"\]

}

data_resource {

type = "AWS::KMS::Key"

values = \["\*"\]

}

}

\# 洞察セレクター（異常検知）

insight_selector {

insight_type = "ApiCallRateInsight"

}

tags = {

Purpose = "Compliance Audit Trail"

Compliance = "SOC2,ISO27001,PCI-DSS"

}

}

\# 監査ログ用S3バケット

resource "aws_s3_bucket" "audit_logs" {

bucket = "technova-audit-logs-\${random_id.audit_suffix.hex}"

tags = {

Purpose = "Audit Log Storage"

Retention = "7years"

Compliance = "SOC2,ISO27001"

}

}

resource "aws_s3_bucket_lifecycle_configuration" "audit_logs_lifecycle"
{

bucket = aws_s3_bucket.audit_logs.id

rule {

id = "audit_log_retention"

status = "Enabled"

\# 90日後にIA移行

transition {

days = 90

storage_class = "STANDARD_IA"

}

\# 1年後にGlacier移行

transition {

days = 365

storage_class = "GLACIER"

}

\# 7年後にDeep Archive移行

transition {

days = 2555 \# 7年

storage_class = "DEEP_ARCHIVE"

}

\# 10年後に削除

expiration {

days = 3650 \# 10年

}

}

}

\# 監査ログへの不正アクセス防止

resource "aws_s3_bucket_policy" "audit_logs_policy" {

bucket = aws_s3_bucket.audit_logs.id

policy = jsonencode({

Version = "2012-10-17"

Statement = \[

{

Sid = "DenyDirectAccess"

Effect = "Deny"

Principal = "\*"

Action = "s3:\*"

Resource = \[

aws_s3_bucket.audit_logs.arn,

"\${aws_s3_bucket.audit_logs.arn}/\*"

\]

Condition = {

StringNotEquals = {

"aws:PrincipalServiceName" = \[

"cloudtrail.amazonaws.com",

"config.amazonaws.com"

\]

}

StringNotLike = {

"aws:PrincipalArn" = \[

"arn:aws:iam::\${var.audit_account_id}:role/AuditRole\*"

\]

}

}

},

{

Sid = "AllowAuditAccountReadOnly"

Effect = "Allow"

Principal = {

AWS = "arn:aws:iam::\${var.audit_account_id}:root"

}

Action = \[

"s3:GetObject",

"s3:ListBucket"

\]

Resource = \[

aws_s3_bucket.audit_logs.arn,

"\${aws_s3_bucket.audit_logs.arn}/\*"

\]

Condition = {

Bool = {

"aws:MultiFactorAuthPresent" = "true"

}

}

}

\]

})

}

5.4 アクセス認証プロセス

python

*\# 四半期アクセス認証の自動化*

import boto3

import json

from datetime import datetime, timedelta

import csv

class AccessCertificationManager:

def \_\_init\_\_(self):

self.iam_client = boto3.client('iam')

self.identity_store = boto3.client('identitystore')

self.sso_admin = boto3.client('sso-admin')

def generate_access_report(self):

"""

全組織のアクセス権限レポート生成

"""

report = {

'generated_at': datetime.now().isoformat(),

'certification_period': self.\_get_certification_period(),

'accounts': \[\]

}

*\# 各アカウントのアクセス情報を収集*

for account in self.\_get_organization_accounts():

account_report = self.\_analyze_account_access(account\['Id'\])

report\['accounts'\].append(account_report)

return report

def \_get_certification_period(self):

"""

認証期間の取得（四半期）

"""

now = datetime.now()

quarter_start = datetime(now.year, ((now.month - 1) // 3) \* 3 + 1, 1)

quarter_end = quarter_start + timedelta(days=90)

return {

'start': quarter_start.isoformat(),

'end': quarter_end.isoformat()

}

def \_analyze_account_access(self, account_id):

"""

アカウント別アクセス分析

"""

try:

*\# アカウント内のIAMユーザー分析*

users_analysis = self.\_analyze_iam_users(account_id)

*\# ロール分析*

roles_analysis = self.\_analyze_iam_roles(account_id)

*\# SSO Permission Sets分析*

sso_analysis = self.\_analyze_sso_assignments(account_id)

return {

'account_id': account_id,

'analysis_date': datetime.now().isoformat(),

'iam_users': users_analysis,

'iam_roles': roles_analysis,

'sso_assignments': sso_analysis,

'compliance_score': self.\_calculate_compliance_score(

users_analysis, roles_analysis, sso_analysis

)

}

except Exception as e:

return {

'account_id': account_id,

'error': str(e),

'analysis_date': datetime.now().isoformat()

}

def \_analyze_iam_users(self, account_id):

"""

IAMユーザーのアクセス分析

"""

*\# AssumeRoleでターゲットアカウントにアクセス*

assumed_role = self.\_assume_audit_role(account_id)

target_iam = boto3.client('iam',

aws_access_key_id=assumed_role\['AccessKeyId'\],

aws_secret_access_key=assumed_role\['SecretAccessKey'\],

aws_session_token=assumed_role\['SessionToken'\]

)

users = target_iam.list_users()\['Users'\]

user_analysis = \[\]

for user in users:

*\# 最終ログイン確認*

last_activity = self.\_get_user_last_activity(target_iam,
user\['UserName'\])

*\# 付与されたポリシー確認*

attached_policies = self.\_get_user_policies(target_iam,
user\['UserName'\])

*\# MFA設定確認*

mfa_devices = target_iam.list_mfa_devices(UserName=user\['UserName'\])

user_analysis.append({

'username': user\['UserName'\],

'creation_date': user\['CreateDate'\].isoformat(),

'last_activity': last_activity,

'attached_policies': attached_policies,

'mfa_enabled': len(mfa_devices\['MFADevices'\]) \> 0,

'compliance_issues': self.\_identify_user_compliance_issues(

user, last_activity, attached_policies, mfa_devices

)

})

return user_analysis

def \_identify_user_compliance_issues(self, user, last_activity,
policies, mfa_devices):

"""

コンプライアンス問題の特定

"""

issues = \[\]

*\# 90日以上未使用*

if last_activity and (datetime.now() - last_activity).days \> 90:

issues.append({

'type': 'UNUSED_ACCOUNT',

'severity': 'MEDIUM',

'description': f'Account unused for {(datetime.now() -
last_activity).days} days'

})

*\# MFA未設定*

if len(mfa_devices\['MFADevices'\]) == 0:

issues.append({

'type': 'MFA_NOT_ENABLED',

'severity': 'HIGH',

'description': 'Multi-Factor Authentication not enabled'

})

*\# 過剰権限の検知*

if any('AdministratorAccess' in policy\['PolicyName'\] for policy in
policies):

issues.append({

'type': 'EXCESSIVE_PRIVILEGES',

'severity': 'HIGH',

'description': 'Administrator access granted to regular user'

})

return issues

def generate_certification_tasks(self, access_report):

"""

認証タスクの生成

"""

certification_tasks = \[\]

for account in access_report\['accounts'\]:

for user in account.get('iam_users', \[\]):

if user.get('compliance_issues'):

task = {

'account_id': account\['account_id'\],

'user': user\['username'\],

'issues': user\['compliance_issues'\],

'recommended_actions':
self.\_generate_remediation_actions(user\['compliance_issues'\]),

'assigned_to': self.\_determine_assignee(account\['account_id'\],
user\['username'\]),

'due_date': (datetime.now() + timedelta(days=30)).isoformat()

}

certification_tasks.append(task)

return certification_tasks

def \_generate_remediation_actions(self, issues):

"""

修復アクションの生成

"""

actions = \[\]

for issue in issues:

if issue\['type'\] == 'UNUSED_ACCOUNT':

actions.append('Disable or remove unused account')

elif issue\['type'\] == 'MFA_NOT_ENABLED':

actions.append('Enable Multi-Factor Authentication')

elif issue\['type'\] == 'EXCESSIVE_PRIVILEGES':

actions.append('Review and reduce privileges to minimum required')

return actions

*\# 実行例*

def lambda_handler(event, context):

"""

四半期アクセス認証Lambda関数

"""

cert_manager = AccessCertificationManager()

*\# アクセスレポート生成*

access_report = cert_manager.generate_access_report()

*\# 認証タスク生成*

certification_tasks =
cert_manager.generate_certification_tasks(access_report)

*\# レポートをS3に保存*

s3_client = boto3.client('s3')

report_key =
f"access-certification/{datetime.now().strftime('%Y-%Q')}/access-report.json"

s3_client.put_object(

Bucket=os.environ\['COMPLIANCE_BUCKET'\],

Key=report_key,

Body=json.dumps(access_report, indent=2, default=str),

ContentType='application/json'

)

*\# ServiceNowにタスク作成（統合されている場合）*

if os.environ.get('SERVICENOW_INTEGRATION'):

create_servicenow_tasks(certification_tasks)

*\# 通知送信*

send_certification_notification(len(certification_tasks), report_key)

return {

'statusCode': 200,

'body': json.dumps({

'report_generated': True,

'tasks_created': len(certification_tasks),

's3_location': f"s3://{os.environ\['COMPLIANCE_BUCKET'\]}/{report_key}"

})

}

6\. セキュリティ境界設計

6.1 多層防御アーキテクチャ

yaml

security_layers:

*\# レイヤー1: 物理的境界（アカウント分離）*

account_isolation:

principle: "完全な論理分離"

implementation: "AWS Organizations + SCP"

scope: "120アカウント構成"

*\# レイヤー2: ネットワーク境界*

network_isolation:

principle: "ゼロトラストネットワーク"

implementation: "VPC + Security Groups + NACLs"

scope: "VPC間通信制御"

*\# レイヤー3: アプリケーション境界*

application_isolation:

principle: "マイクロセグメンテーション"

implementation: "IAM + Resource Tags + Policies"

scope: "リソースレベルアクセス制御"

*\# レイヤー4: データ境界*

data_isolation:

principle: "暗号化とアクセス制御"

implementation: "KMS + S3 Bucket Policies + Database Security"

scope: "データレベル保護"

6.2 Service Control Policies (SCP) 実装

json

{

"Version": "2012-10-17",

"Statement": \[

{

"Sid": "DenyRootUserActions",

"Effect": "Deny",

"Principal": "\*",

"Action": "\*",

"Resource": "\*",

"Condition": {

"StringEquals": {

"aws:PrincipalType": "Root"

},

"StringNotEquals": {

"aws:PrincipalServiceName": \[

"cloudformation.amazonaws.com",

"config.amazonaws.com"

\]

}

}

},

{

"Sid": "RestrictRegions",

"Effect": "Deny",

"Principal": "\*",

"Action": "\*",

"Resource": "\*",

"Condition": {

"StringNotEquals": {

"aws:RequestedRegion": \[

"ap-northeast-1",

"us-east-1",

"eu-west-1"

\]

},

"ForAllValues:StringNotEquals": {

"aws:PrincipalServiceName": \[

"cloudformation.amazonaws.com",

"support.amazonaws.com"

\]

}

}

},

{

"Sid": "DenyUnencryptedStorage",

"Effect": "Deny",

"Principal": "\*",

"Action": \[

"s3:PutObject",

"rds:CreateDBInstance",

"ec2:CreateVolume"

\],

"Resource": "\*",

"Condition": {

"Bool": {

"aws:SecureTransport": "false"

}

}

},

{

"Sid": "RestrictInstanceTypes",

"Effect": "Deny",

"Principal": "\*",

"Action": \[

"ec2:RunInstances",

"ec2:StartInstances"

\],

"Resource": "arn:aws:ec2:\*:\*:instance/\*",

"Condition": {

"ForAllValues:StringNotLike": {

"ec2:InstanceType": \[

"t3.\*",

"t4g.\*",

"m5.\*",

"m6i.\*",

"c5.\*",

"c6i.\*"

\]

}

}

}

\]

}

6.3 データ分類とアクセス制御

hcl

*\# データ分類に基づくS3バケットポリシー*

resource "aws_s3_bucket_policy" "data_classification_policy" {

bucket = aws_s3_bucket.classified_data.id

policy = jsonencode({

Version = "2012-10-17"

Statement = \[

{

Sid = "RestrictedDataAccess"

Effect = "Allow"

Principal = {

AWS = \[

"arn:aws:iam::\${data.aws_caller_identity.current.account_id}:role/DataScientistRole",

"arn:aws:iam::\${data.aws_caller_identity.current.account_id}:role/ComplianceAuditorRole"

\]

}

Action = \[

"s3:GetObject"

\]

Resource = "\${aws_s3_bucket.classified_data.arn}/restricted/\*"

Condition = {

StringEquals = {

"s3:x-amz-server-side-encryption" = "aws:kms",

"aws:userid" = \[

"\${aws_iam_role.data_scientist.unique_id}:\*",

"\${aws_iam_role.compliance_auditor.unique_id}:\*"

\]

}

Bool = {

"aws:MultiFactorAuthPresent" = "true"

}

DateGreaterThan = {

"aws:TokenIssueTime" = "2024-01-01T00:00:00Z"

}

}

},

{

Sid = "PublicDataAccess"

Effect = "Allow"

Principal = {

AWS =
"arn:aws:iam::\${data.aws_caller_identity.current.account_id}:root"

}

Action = \[

"s3:GetObject"

\]

Resource = "\${aws_s3_bucket.classified_data.arn}/public/\*"

},

{

Sid = "DenyUnencryptedUploads"

Effect = "Deny"

Principal = "\*"

Action = "s3:PutObject"

Resource = "\${aws_s3_bucket.classified_data.arn}/\*"

Condition = {

StringNotEquals = {

"s3:x-amz-server-side-encryption" = "aws:kms"

}

}

}

\]

})

}

*\# KMSキーによるデータ暗号化制御*

resource "aws_kms_key" "data_encryption_key" {

description = "Data encryption key with role-based access"

policy = jsonencode({

Version = "2012-10-17"

Statement = \[

{

Sid = "Enable IAM User Permissions"

Effect = "Allow"

Principal = {

AWS =
"arn:aws:iam::\${data.aws_caller_identity.current.account_id}:root"

}

Action = "kms:\*"

Resource = "\*"

},

{

Sid = "Allow use of the key for specific roles"

Effect = "Allow"

Principal = {

AWS = \[

aws_iam_role.data_scientist.arn,

aws_iam_role.compliance_auditor.arn

\]

}

Action = \[

"kms:Encrypt",

"kms:Decrypt",

"kms:ReEncrypt\*",

"kms:GenerateDataKey\*",

"kms:DescribeKey"

\]

Resource = "\*"

Condition = {

StringEquals = {

"kms:ViaService": \[

"s3.ap-northeast-1.amazonaws.com",

"rds.ap-northeast-1.amazonaws.com"

\]

}

}

}

\]

})

tags = {

Purpose = "Data Classification Encryption"

DataClassification = "Restricted"

}

}

7\. 緊急時アクセス管理

7.1 Break Glass アクセス設計

hcl

*\# 緊急時アクセス用のIAMロール*

resource "aws_iam_role" "emergency_access_role" {

name = "EmergencyBreakGlassRole"

assume_role_policy = jsonencode({

Version = "2012-10-17"

Statement = \[

{

Effect = "Allow"

Principal = {

AWS = \[

for user in var.emergency_access_users :

"arn:aws:iam::\${data.aws_caller_identity.current.account_id}:user/\${user}"

\]

}

Action = "sts:AssumeRole"

Condition = {

Bool = {

"aws:MultiFactorAuthPresent" = "true"

}

StringEquals = {

"sts:ExternalId" = var.emergency_external_id

}

IpAddress = {

"aws:SourceIp" = var.emergency_access_ips

}

}

}

\]

})

*\# セッション期間を1時間に制限*

max_session_duration = 3600

tags = {

Purpose = "Emergency Break Glass Access"

CriticalRole = "true"

}

}

*\# 緊急時用のポリシー（制限付きAdministratorAccess）*

resource "aws_iam_role_policy" "emergency_access_policy" {

name = "EmergencyAccessPolicy"

role = aws_iam_role.emergency_access_role.id

policy = jsonencode({

Version = "2012-10-17"

Statement = \[

{

Effect = "Allow"

Action = "\*"

Resource = "\*"

Condition = {

StringNotEquals = {

"aws:PrincipalServiceName": \[

"organizations.amazonaws.com",

"account.amazonaws.com"

\]

}

}

},

{

Effect = "Deny"

Action = \[

"organizations:\*",

"account:CloseAccount",

"iam:DeleteRole",

"iam:DeleteUser"

\]

Resource = "\*"

}

\]

})

}

7.2 緊急時アクセス監視システム

python

*\# 緊急時アクセス監視Lambda関数*

import boto3

import json

import os

from datetime import datetime

def lambda_handler(event, context):

"""

Break Glassロールの使用を監視・通知

"""

try:

*\# CloudTrailイベントから緊急時アクセスを検出*

records = event.get('Records', \[\])

for record in records:

if 'cloudtrail' in record.get('eventSource', '').lower():

cloudtrail_data = json.loads(record\['body'\])

*\# AssumeRoleイベントの確認*

if cloudtrail_data.get('eventName') == 'AssumeRole':

role_arn = cloudtrail_data.get('responseElements',
{}).get('assumedRoleUser', {}).get('arn', '')

*\# Break Glassロールの使用検出*

if 'EmergencyBreakGlassRole' in role_arn:

handle_emergency_access_event(cloudtrail_data)

except Exception as e:

print(f"Error processing emergency access event: {str(e)}")

send_error_notification(str(e))

return {'statusCode': 200}

def handle_emergency_access_event(event_data):

"""

緊急時アクセスイベントの処理

"""

*\# イベント詳細の抽出*

user_identity = event_data.get('userIdentity', {})

source_ip = event_data.get('sourceIPAddress', 'Unknown')

event_time = event_data.get('eventTime', datetime.now().isoformat())

user_name = user_identity.get('userName', 'Unknown')

mfa_used = event_data.get('requestContext', {}).get('mfaAuthenticated',
False)

*\# セキュリティ情報の収集*

security_context = {

'user_name': user_name,

'source_ip': source_ip,

'event_time': event_time,

'mfa_authenticated': mfa_used,

'user_agent': event_data.get('userAgent', 'Unknown'),

'aws_region': event_data.get('awsRegion', 'Unknown')

}

*\# DynamoDBに記録*

record_emergency_access(security_context)

*\# 即座に通知送信*

send_emergency_access_alert(security_context)

*\# 追加の監視開始*

initiate_enhanced_monitoring(user_name, source_ip)

def record_emergency_access(security_context):

"""

緊急時アクセスをDynamoDBに記録

"""

dynamodb = boto3.resource('dynamodb')

table = dynamodb.Table(os.environ\['EMERGENCY_ACCESS_TABLE'\])

try:

table.put_item(

Item={

'access_id':
f"{security_context\['user_name'\]}-{security_context\['event_time'\]}",

'user_name': security_context\['user_name'\],

'source_ip': security_context\['source_ip'\],

'event_time': security_context\['event_time'\],

'mfa_authenticated': security_context\['mfa_authenticated'\],

'user_agent': security_context\['user_agent'\],

'aws_region': security_context\['aws_region'\],

'status': 'ACTIVE',

'created_at': datetime.now().isoformat(),

'ttl': int((datetime.now().timestamp() + (365 \* 24 \* 60 \* 60))) *\#
1年保持*

}

)

except Exception as e:

print(f"Failed to record emergency access: {str(e)}")

def send_emergency_access_alert(security_context):

"""

緊急時アクセスアラートの送信

"""

sns = boto3.client('sns')

*\# アラートメッセージの作成*

alert_message = f"""

🚨 CRITICAL: Emergency Break Glass Access Detected 🚨

User: {security_context\['user_name'\]}

Time: {security_context\['event_time'\]}

Source IP: {security_context\['source_ip'\]}

MFA Used: {'Yes' if security_context\['mfa_authenticated'\] else 'No'}

User Agent: {security_context\['user_agent'\]}

Region: {security_context\['aws_region'\]}

This is an automated alert for emergency administrative access.

Immediate investigation required.

Security Dashboard: https://console.aws.amazon.com/securityhub/

CloudTrail Logs: https://console.aws.amazon.com/cloudtrail/

"""

*\# 複数チャネルに通知*

notification_topics = \[

os.environ\['SECURITY_ALERTS_TOPIC'\],

os.environ\['EMERGENCY_ALERTS_TOPIC'\]

\]

for topic_arn in notification_topics:

try:

sns.publish(

TopicArn=topic_arn,

Subject="🚨 EMERGENCY: Break Glass Access Detected",

Message=alert_message

)

except Exception as e:

print(f"Failed to send alert to {topic_arn}: {str(e)}")

def initiate_enhanced_monitoring(user_name, source_ip):

"""

緊急時アクセス後の強化監視開始

"""

cloudwatch = boto3.client('cloudwatch')

*\# カスタムメトリクスアラームの作成*

try:

cloudwatch.put_metric_alarm(

AlarmName=f'EmergencyAccess-{user_name}-EnhancedMonitoring',

ComparisonOperator='GreaterThanThreshold',

EvaluationPeriods=1,

MetricName='APICallCount',

Namespace='TechNova/EmergencyAccess',

Period=300, *\# 5分間隔*

Statistic='Sum',

Threshold=50.0, *\# 5分間で50回以上のAPI呼び出し*

ActionsEnabled=True,

AlarmActions=\[

os.environ\['EMERGENCY_ALERTS_TOPIC'\]

\],

AlarmDescription=f'Enhanced monitoring for emergency access by
{user_name}',

Dimensions=\[

{

'Name': 'UserName',

'Value': user_name

},

{

'Name': 'SourceIP',

'Value': source_ip

}

\]

)

except Exception as e:

print(f"Failed to create enhanced monitoring alarm: {str(e)}")

7.3 緊急時プロシージャ

yaml

emergency_procedures:

*\# レベル1: サービス障害対応*

service_outage:

trigger: "重要サービスの完全停止"

response_time: "15分以内"

authorized_personnel:

\- "SREチームリーダー"

\- "ITマネージャー"

access_scope: "影響を受けたサービスのアカウントのみ"

approval_process: "口頭承認 + 事後報告"

*\# レベル2: セキュリティインシデント*

security_incident:

trigger: "セキュリティ侵害の疑い"

response_time: "5分以内"

authorized_personnel:

\- "CISOまたは代理"

\- "セキュリティチームリーダー"

access_scope: "全アカウント（必要に応じて）"

approval_process: "CISO承認 + リアルタイム監視"

*\# レベル3: 法的・規制対応*

legal_compliance:

trigger: "法執行機関からの要請"

response_time: "状況に応じて"

authorized_personnel:

\- "法務部長"

\- "コンプライアンス責

再試行

C

続ける

編集

authorized_personnel: - "法務部長" - "コンプライアンス責任者" -
"CEO承認済み担当者" access_scope: "要請対象のアカウント・データのみ"
approval_process: "CEO + 法務部長の書面承認"

emergency_access_matrix: break_glass_levels: level_1_service_recovery:
max_duration: "2時間" required_approvals: 1 post_incident_review:
"24時間以内" automatic_revocation: true

level_2_security_response:

max_duration: "4時間"

required_approvals: 2

post_incident_review: "12時間以内"

automatic_revocation: true

continuous_monitoring: true

level_3_legal_compliance:

max_duration: "状況に応じて"

required_approvals: 3

post_incident_review: "即時"

automatic_revocation: false

legal_documentation: true

post_emergency_procedures: immediate_actions: - "アクセス終了の確認" -
"実行されたアクションの記録" - "関係者への報告"

documentation_requirements: - "緊急時アクセス理由書" -
"実行されたコマンド・変更のログ" - "インシデント対応レポート" -
"改善提案書"

review_process: - "48時間以内のレビュー会議" - "根本原因分析" -
"プロセス改善の検討" - "必要に応じた権限見直し"

\## 8. 監視・ログ戦略

\### 8.1 包括的監視アーキテクチャ

\`\`\`hcl

\# AWS Config - 設定変更監視

resource "aws_config_configuration_recorder" "security_recorder" {

name = "TechNova-Security-Configuration-Recorder"

role_arn = aws_iam_role.config_recorder_role.arn

recording_group {

all_supported = true

include_global_resource_types = true

\# 重要なリソースタイプを明示的に指定

resource_types = \[

"AWS::IAM::Role",

"AWS::IAM::Policy",

"AWS::IAM::User",

"AWS::S3::Bucket",

"AWS::KMS::Key",

"AWS::EC2::SecurityGroup",

"AWS::Organizations::Account"

\]

}

depends_on = \[aws_config_delivery_channel.security_channel\]

}

\# GuardDuty - 脅威検出

resource "aws_guardduty_detector" "main" {

enable = true

\# S3保護の有効化

datasources {

s3_logs {

enable = true

}

kubernetes {

audit_logs {

enable = true

}

}

malware_protection {

scan_ec2_instance_with_findings {

ebs_volumes {

enable = true

}

}

}

}

tags = {

Purpose = "Threat Detection"

Environment = "Organization"

}

}

\# Security Hub - 統合セキュリティ監視

resource "aws_securityhub_account" "main" {

enable_default_standards = true

}

\# CloudWatch メトリクスフィルター - 重要なIAMイベント

resource "aws_cloudwatch_log_metric_filter" "root_usage" {

name = "RootAccountUsage"

log_group_name = aws_cloudwatch_log_group.cloudtrail.name

pattern = "{ \$.userIdentity.type = \\Root\\ &&
\$.userIdentity.invokedBy NOT EXISTS && \$.eventType !=
\\AwsServiceEvent\\ }"

metric_transformation {

name = "RootAccountUsageCount"

namespace = "TechNova/Security"

value = "1"

}

}

resource "aws_cloudwatch_log_metric_filter" "unauthorized_api_calls" {

name = "UnauthorizedAPICalls"

log_group_name = aws_cloudwatch_log_group.cloudtrail.name

pattern = "{ (\$.errorCode = \\\*UnauthorizedOperation\\) \|\|
(\$.errorCode = \\AccessDenied\*\\) }"

metric_transformation {

name = "UnauthorizedAPICallsCount"

namespace = "TechNova/Security"

value = "1"

}

}

resource "aws_cloudwatch_log_metric_filter" "iam_policy_changes" {

name = "IAMPolicyChanges"

log_group_name = aws_cloudwatch_log_group.cloudtrail.name

pattern = "{ (\$.eventName = CreatePolicy) \|\| (\$.eventName =
DeletePolicy) \|\| (\$.eventName = CreatePolicyVersion) \|\|
(\$.eventName = DeletePolicyVersion) \|\| (\$.eventName =
AttachRolePolicy) \|\| (\$.eventName = DetachRolePolicy) }"

metric_transformation {

name = "IAMPolicyChangesCount"

namespace = "TechNova/Security"

value = "1"

}

}

8.2 リアルタイム脅威検出

python

*\# リアルタイム脅威検出Lambda関数*

import boto3

import json

import os

from datetime import datetime

import hashlib

class ThreatDetectionEngine:

def \_\_init\_\_(self):

self.guardduty = boto3.client('guardduty')

self.securityhub = boto3.client('securityhub')

self.sns = boto3.client('sns')

self.dynamodb = boto3.resource('dynamodb')

self.threat_table =
self.dynamodb.Table(os.environ\['THREAT_DETECTION_TABLE'\])

def process_security_event(self, event):

"""

セキュリティイベントの処理

"""

try:

*\# イベントソースの判定*

if 'guardduty' in event.get('source', '').lower():

return self.handle_guardduty_finding(event)

elif 'securityhub' in event.get('source', '').lower():

return self.handle_securityhub_finding(event)

elif 'cloudtrail' in event.get('source', '').lower():

return self.handle_cloudtrail_event(event)

else:

return self.handle_generic_security_event(event)

except Exception as e:

print(f"Error processing security event: {str(e)}")

return {'statusCode': 500, 'error': str(e)}

def handle_guardduty_finding(self, event):

"""

GuardDuty脅威検出の処理

"""

detail = event.get('detail', {})

finding_id = detail.get('id', 'unknown')

severity = detail.get('severity', 0)

finding_type = detail.get('type', 'Unknown')

*\# 脅威レベルの判定*

threat_level = self.determine_threat_level(severity, finding_type)

*\# 脅威情報の記録*

threat_record = {

'finding_id': finding_id,

'source': 'GuardDuty',

'type': finding_type,

'severity': severity,

'threat_level': threat_level,

'timestamp': datetime.now().isoformat(),

'account_id': detail.get('accountId', 'unknown'),

'region': detail.get('region', 'unknown'),

'resource': detail.get('resource', {}),

'evidence': detail.get('service', {}).get('evidence', {})

}

self.store_threat_record(threat_record)

*\# 自動対応の実行*

if threat_level in \['CRITICAL', 'HIGH'\]:

self.initiate_automated_response(threat_record)

*\# 通知送信*

self.send_threat_notification(threat_record)

return {'statusCode': 200, 'threat_level': threat_level}

def determine_threat_level(self, severity, finding_type):

"""

脅威レベルの判定

"""

*\# GuardDutyの数値重要度を文字列に変換*

if severity \>= 7.0:

base_level = 'HIGH'

elif severity \>= 4.0:

base_level = 'MEDIUM'

else:

base_level = 'LOW'

*\# 脅威タイプによる調整*

critical_threats = \[

'UnauthorizedAPICall',

'InstanceCredentialExfiltration',

'CryptoCurrency',

'Backdoor',

'Trojan'

\]

high_priority_threats = \[

'Recon',

'ResourceConsumption',

'Stealth',

'Persistence'

\]

if any(critical in finding_type for critical in critical_threats):

return 'CRITICAL'

elif any(high in finding_type for high in high_priority_threats):

return 'HIGH' if base_level != 'LOW' else 'MEDIUM'

else:

return base_level

def initiate_automated_response(self, threat_record):

"""

自動対応の実行

"""

finding_type = threat_record\['type'\]

resource = threat_record.get('resource', {})

try:

*\# EC2インスタンス関連の脅威*

if 'EC2' in resource.get('resourceType', ''):

instance_id = resource.get('instanceDetails', {}).get('instanceId')

if instance_id:

self.isolate_ec2_instance(instance_id, threat_record\['account_id'\])

*\# IAM関連の脅威*

elif 'IAMUser' in resource.get('resourceType', ''):

user_name = resource.get('accessKeyDetails', {}).get('userName')

if user_name:

self.disable_iam_user(user_name, threat_record\['account_id'\])

*\# S3関連の脅威*

elif 'S3Bucket' in resource.get('resourceType', ''):

bucket_name = resource.get('s3BucketDetails', \[{}\])\[0\].get('name')

if bucket_name:

self.secure_s3_bucket(bucket_name, threat_record\['account_id'\])

except Exception as e:

print(f"Automated response failed: {str(e)}")

*\# 自動対応失敗の通知*

self.send_response_failure_alert(threat_record, str(e))

def isolate_ec2_instance(self, instance_id, account_id):

"""

EC2インスタンスの隔離

"""

*\# クロスアカウントロールでターゲットアカウントにアクセス*

assumed_role = self.assume_security_role(account_id)

ec2 = boto3.client('ec2',

aws_access_key_id=assumed_role\['AccessKeyId'\],

aws_secret_access_key=assumed_role\['SecretAccessKey'\],

aws_session_token=assumed_role\['SessionToken'\]

)

try:

*\# 隔離用セキュリティグループの作成/取得*

isolation_sg = self.get_or_create_isolation_security_group(ec2)

*\# インスタンスのセキュリティグループを隔離用に変更*

ec2.modify_instance_attribute(

InstanceId=instance_id,

Groups=\[isolation_sg\['GroupId'\]\]

)

*\# インスタンスにタグ付け*

ec2.create_tags(

Resources=\[instance_id\],

Tags=\[

{'Key': 'SecurityStatus', 'Value': 'ISOLATED'},

{'Key': 'IsolationReason', 'Value': 'GuardDuty_Threat_Detection'},

{'Key': 'IsolationTime', 'Value': datetime.now().isoformat()}

\]

)

print(f"Successfully isolated EC2 instance: {instance_id}")

except Exception as e:

print(f"Failed to isolate EC2 instance {instance_id}: {str(e)}")

raise

def disable_iam_user(self, user_name, account_id):

"""

IAMユーザーの無効化

"""

assumed_role = self.assume_security_role(account_id)

iam = boto3.client('iam',

aws_access_key_id=assumed_role\['AccessKeyId'\],

aws_secret_access_key=assumed_role\['SecretAccessKey'\],

aws_session_token=assumed_role\['SessionToken'\]

)

try:

*\# アクセスキーの無効化*

access_keys = iam.list_access_keys(UserName=user_name)

for key in access_keys\['AccessKeyMetadata'\]:

iam.update_access_key(

UserName=user_name,

AccessKeyId=key\['AccessKeyId'\],

Status='Inactive'

)

*\# ユーザーにタグ付け*

iam.tag_user(

UserName=user_name,

Tags=\[

{'Key': 'SecurityStatus', 'Value': 'DISABLED'},

{'Key': 'DisableReason', 'Value': 'GuardDuty_Threat_Detection'},

{'Key': 'DisableTime', 'Value': datetime.now().isoformat()}

\]

)

print(f"Successfully disabled IAM user: {user_name}")

except Exception as e:

print(f"Failed to disable IAM user {user_name}: {str(e)}")

raise

def send_threat_notification(self, threat_record):

"""

脅威通知の送信

"""

threat_level = threat_record\['threat_level'\]

*\# 通知内容の作成*

notification_message = f"""

🚨 SECURITY THREAT DETECTED 🚨

Threat Level: {threat_level}

Source: {threat_record\['source'\]}

Type: {threat_record\['type'\]}

Severity: {threat_record\['severity'\]}

Account: {threat_record\['account_id'\]}

Region: {threat_record\['region'\]}

Time: {threat_record\['timestamp'\]}

Resource Details:

{json.dumps(threat_record\['resource'\], indent=2)}

Automated Response: {'Initiated' if threat_level in \['CRITICAL',
'HIGH'\] else 'Not Required'}

View in Security Hub: https://console.aws.amazon.com/securityhub/

View in GuardDuty: https://console.aws.amazon.com/guardduty/

"""

*\# 脅威レベルに応じた通知先の選択*

if threat_level == 'CRITICAL':

topic_arn = os.environ\['CRITICAL_SECURITY_ALERTS_TOPIC'\]

elif threat_level == 'HIGH':

topic_arn = os.environ\['HIGH_SECURITY_ALERTS_TOPIC'\]

else:

topic_arn = os.environ\['GENERAL_SECURITY_ALERTS_TOPIC'\]

try:

self.sns.publish(

TopicArn=topic_arn,

Subject=f"🚨 {threat_level} Security Threat: {threat_record\['type'\]}",

Message=notification_message

)

except Exception as e:

print(f"Failed to send threat notification: {str(e)}")

def lambda_handler(event, context):

"""

脅威検出Lambda関数のメインハンドラー

"""

detector = ThreatDetectionEngine()

try:

*\# イベントレコードの処理*

if 'Records' in event:

results = \[\]

for record in event\['Records'\]:

*\# SNSレコードからの実際のイベント抽出*

if 'Sns' in record:

actual_event = json.loads(record\['Sns'\]\['Message'\])

result = detector.process_security_event(actual_event)

results.append(result)

return {'statusCode': 200, 'results': results}

else:

*\# 直接のイベント処理*

return detector.process_security_event(event)

except Exception as e:

print(f"Lambda handler error: {str(e)}")

return {'statusCode': 500, 'error': str(e)}

8.3 セキュリティメトリクスとアラート

hcl

*\# CloudWatch アラーム設定*

resource "aws_cloudwatch_metric_alarm" "root_account_usage" {

alarm_name = "RootAccountUsage"

comparison_operator = "GreaterThanOrEqualToThreshold"

evaluation_periods = "1"

metric_name = "RootAccountUsageCount"

namespace = "TechNova/Security"

period = "60"

statistic = "Sum"

threshold = "1"

alarm_description = "Root account usage detected"

alarm_actions = \[aws_sns_topic.critical_security_alerts.arn\]

tags = {

Severity = "CRITICAL"

Purpose = "Root Account Monitoring"

}

}

resource "aws_cloudwatch_metric_alarm" "failed_console_logins" {

alarm_name = "FailedConsoleLogins"

comparison_operator = "GreaterThanThreshold"

evaluation_periods = "2"

metric_name = "ConsoleLoginFailures"

namespace = "TechNova/Security"

period = "300"

statistic = "Sum"

threshold = "5"

alarm_description = "Multiple failed console login attempts detected"

alarm_actions = \[aws_sns_topic.security_alerts.arn\]

tags = {

Severity = "HIGH"

Purpose = "Login Monitoring"

}

}

*\# GuardDutyカスタムアラート*

resource "aws_cloudwatch_event_rule" "guardduty_high_severity" {

name = "guardduty-high-severity-findings"

description = "GuardDuty high severity findings"

event_pattern = jsonencode({

source = \["aws.guardduty"\]

detail-type = \["GuardDuty Finding"\]

detail = {

severity = \[{

numeric = \["\>", 7.0\]

}\]

}

})

}

resource "aws_cloudwatch_event_target" "guardduty_lambda_target" {

rule = aws_cloudwatch_event_rule.guardduty_high_severity.name

target_id = "GuardDutyLambdaTarget"

arn = aws_lambda_function.threat_detection.arn

}

*\# セキュリティメトリクスダッシュボード*

resource "aws_cloudwatch_dashboard" "security_metrics" {

dashboard_name = "TechNova-Security-Metrics"

dashboard_body = jsonencode({

widgets = \[

{

type = "metric"

x = 0

y = 0

width = 12

height = 6

properties = {

metrics = \[

\["TechNova/Security", "RootAccountUsageCount"\],

\[".", "UnauthorizedAPICallsCount"\],

\[".", "IAMPolicyChangesCount"\],

\[".", "ConsoleLoginFailures"\]

\]

view = "timeSeries"

stacked = false

region = "ap-northeast-1"

title = "Security Events Timeline"

period = 300

}

},

{

type = "metric"

x = 12

y = 0

width = 12

height = 6

properties = {

metrics = \[

\["AWS/GuardDuty", "FindingCount", "DetectorId",
aws_guardduty_detector.main.id\]

\]

view = "timeSeries"

stacked = false

region = "ap-northeast-1"

title = "GuardDuty Findings"

period = 300

}

},

{

type = "log"

x = 0

y = 6

width = 24

height = 6

properties = {

query = "SOURCE '/aws/lambda/threat-detection' \| fields @timestamp,
@message \| filter @message like /CRITICAL/ \| sort @timestamp desc \|
limit 20"

region = "ap-northeast-1"

title = "Critical Security Events"

view = "table"

}

}

\]

})

}

9\. 実装ガイドライン

9.1 フェーズ別実装計画

yaml

implementation_phases:

*\# フェーズ1: 基盤構築（1-2ヶ月）*

phase_1_foundation:

duration: "8週間"

objectives:

\- "IAM Identity Center設定"

\- "基本Permission Set作成"

\- "CloudTrail・Config設定"

\- "基本監視の実装"

deliverables:

\- "Identity Center統合完了"

\- "基本権限体系構築"

\- "監査ログ基盤構築"

success_criteria:

\- "全アカウントでSSO認証可能"

\- "監査ログ100%取得"

\- "基本セキュリティアラート動作"

*\# フェーズ2: 権限最適化（2-3ヶ月）*

phase_2_optimization:

duration: "6週間"

objectives:

\- "最小権限ポリシー実装"

\- "ABAC導入"

\- "JITアクセス実装"

\- "クロスアカウント権限最適化"

deliverables:

\- "カスタムPermission Set完了"

\- "JITアクセス機能稼働"

\- "権限認証プロセス確立"

success_criteria:

\- "過剰権限50%削減"

\- "JITアクセス利用率80%"

\- "権限認証プロセス100%遵守"

*\# フェーズ3: 高度なセキュリティ（3-4ヶ月）*

phase_3_advanced_security:

duration: "6週間"

objectives:

\- "脅威検出システム完全実装"

\- "自動対応機能実装"

\- "Break Glassプロセス確立"

\- "コンプライアンス自動化"

deliverables:

\- "脅威検出・対応システム稼働"

\- "緊急時アクセス体制確立"

\- "コンプライアンス監視自動化"

success_criteria:

\- "脅威検出率95%以上"

\- "自動対応時間5分以内"

\- "コンプライアンス準拠率100%"

*\# フェーズ4: 運用最適化（継続）*

phase_4_optimization:

duration: "継続的"

objectives:

\- "運用プロセス最適化"

\- "性能監視・改善"

\- "セキュリティポスチャ向上"

\- "ユーザビリティ改善"

deliverables:

\- "運用手順書完備"

\- "性能ベンチマーク確立"

\- "継続的改善プロセス"

success_criteria:

\- "運用効率20%向上"

\- "ユーザー満足度90%以上"

\- "セキュリティインシデント0件"

9.2 実装チェックリスト

yaml

implementation_checklist:

*\# 事前準備*

prerequisites:

\- name: "AWS Organizations設定確認"

status: "required"

owner: "IT管理者"

estimated_hours: 8

\- name: "既存IAMユーザー・ロール調査"

status: "required"

owner: "セキュリティチーム"

estimated_hours: 40

\- name: "コンプライアンス要件整理"

status: "required"

owner: "コンプライアンス"

estimated_hours: 16

\- name: "既存権限の文書化"

status: "required"

owner: "各事業部門"

estimated_hours: 80

*\# IAM Identity Center設定*

identity_center_setup:

\- name: "Identity Center有効化"

status: "required"

owner: "IT管理者"

estimated_hours: 4

dependencies: \["Organizations設定確認"\]

\- name: "外部IDプロバイダー統合"

status: "required"

owner: "IT管理者"

estimated_hours: 16

dependencies: \["Identity Center有効化"\]

\- name: "基本Permission Set作成"

status: "required"

owner: "セキュリティチーム"

estimated_hours: 24

dependencies: \["外部IDプロバイダー統合"\]

\- name: "ユーザー・グループマッピング"

status: "required"

owner: "HR・IT管理者"

estimated_hours: 32

dependencies: \["基本Permission Set作成"\]

*\# セキュリティ監視設定*

security_monitoring:

\- name: "CloudTrail組織レベル設定"

status: "required"

owner: "セキュリティチーム"

estimated_hours: 8

\- name: "GuardDuty全アカウント有効化"

status: "required"

owner: "セキュリティチーム"

estimated_hours: 16

\- name: "Security Hub統合設定"

status: "required"

owner: "セキュリティチーム"

estimated_hours: 12

\- name: "Config Rules設定"

status: "required"

owner: "セキュリティチーム"

estimated_hours: 20

*\# 権限最適化*

permission_optimization:

\- name: "最小権限ポリシー作成"

status: "required"

owner: "セキュリティチーム"

estimated_hours: 60

\- name: "ABAC実装"

status: "recommended"

owner: "セキュリティチーム"

estimated_hours: 40

\- name: "JITアクセス実装"

status: "recommended"

owner: "セキュリティチーム"

estimated_hours: 80

\- name: "クロスアカウント権限整理"

status: "required"

owner: "セキュリティチーム"

estimated_hours: 48

*\# テスト・検証*

testing_validation:

\- name: "権限テストシナリオ実行"

status: "required"

owner: "セキュリティチーム"

estimated_hours: 40

\- name: "緊急時アクセステスト"

status: "required"

owner: "セキュリティチーム"

estimated_hours: 16

\- name: "ユーザー受け入れテスト"

status: "required"

owner: "各事業部門"

estimated_hours: 80

\- name: "性能・可用性テスト"

status: "recommended"

owner: "SREチーム"

estimated_hours: 32

estimated_total_effort:

total_hours: 592

total_weeks: "約15週間（複数人並行作業想定）"

critical_path: "既存権限調査 → Permission Set作成 → ユーザーマッピング →
テスト"

9.3 トレーニングと変更管理

yaml

training_change_management:

*\# ステークホルダー別トレーニング*

stakeholder_training:

executives:

content:

\- "セキュリティガバナンス概要"

\- "コンプライアンス要件と対応"

\- "ROI・リスク削減効果"

duration: "2時間"

delivery_method: "プレゼンテーション"

it_administrators:

content:

\- "IAM Identity Center管理"

\- "Permission Set設計・運用"

\- "トラブルシューティング"

\- "緊急時対応手順"

duration: "2日間"

delivery_method: "ハンズオン研修"

security_team:

content:

\- "セキュリティ監視・分析"

\- "脅威検出・対応"

\- "コンプライアンス監査"

\- "インシデント対応"

duration: "3日間"

delivery_method: "専門研修"

end_users:

content:

\- "新しいログイン方法"

\- "権限申請プロセス"

\- "セキュリティベストプラクティス"

duration: "1時間"

delivery_method: "eラーニング"

developers:

content:

\- "開発環境でのアクセス管理"

\- "IaCでの権限設定"

\- "セキュリティ考慮事項"

duration: "4時間"

delivery_method: "技術研修"

*\# 変更管理プロセス*

change_management:

communication_plan:

\- phase: "事前告知（4週間前）"

content: "変更概要・スケジュール・影響"

channels: \["全社メール", "イントラネット"\]

\- phase: "詳細説明（2週間前）"

content: "具体的な変更内容・手順"

channels: \["部門説明会", "FAQ公開"\]

\- phase: "直前リマインダー（1週間前）"

再試行

C

続ける

編集

content: "最終確認・準備事項" channels: \["個別メール", "Slack通知"\]

\- phase: "実施中（リアルタイム）"

content: "進捗状況・問題報告"

channels: \["専用Slackチャネル", "ステータスページ"\]

\- phase: "完了報告（実施後）"

content: "完了確認・次のステップ"

channels: \["全社メール", "成果レポート"\]

risk_mitigation:

rollback_plan:

\- "各フェーズでのロールバックポイント設定"

\- "緊急時の権限復旧手順"

\- "ビジネス継続性確保策"

user_support:

\- "移行期間中のヘルプデスク体制強化"

\- "FAQ・トラブルシューティングガイド"

\- "エスカレーション手順明確化"

business_continuity:

\- "段階的移行による影響最小化"

\- "重要業務への影響回避"

\- "緊急時アクセス経路確保"

成功指標とモニタリング

success_metrics: adoption_metrics: - name: "SSO利用率" target: "95%以上"
measurement: "月次"

\- name: "権限申請処理時間"

target: "平均2時間以内"

measurement: "週次"

\- name: "ユーザー満足度"

target: "4.0/5.0以上"

measurement: "四半期"

security_metrics:

\- name: "過剰権限削減率"

target: "50%以上削減"

measurement: "月次"

\- name: "セキュリティインシデント"

target: "前年比50%削減"

measurement: "月次"

\- name: "コンプライアンススコア"

target: "95%以上"

measurement: "月次"

operational_metrics:

\- name: "権限管理工数"

target: "前年比30%削減"

measurement: "四半期"

\- name: "システム可用性"

target: "99.9%以上"

measurement: "月次"

\- name: "問い合わせ件数"

target: "導入前の20%以下"

measurement: "週次"

\### 9.4 運用・保守計画

\`\`\`yaml

operations_maintenance:

\# 日常運用業務

daily_operations:

monitoring_tasks:

\- name: "セキュリティアラート確認"

frequency: "毎時"

owner: "NOCチーム"

estimated_time: "15分"

\- name: "システム健全性チェック"

frequency: "日次"

owner: "SREチーム"

estimated_time: "30分"

\- name: "権限申請処理"

frequency: "随時"

owner: "IT管理者"

estimated_time: "1件10分"

incident_response:

\- name: "セキュリティインシデント対応"

sla: "検知から15分以内"

owner: "セキュリティチーム"

\- name: "システム障害対応"

sla: "検知から30分以内"

owner: "SREチーム"

\- name: "権限関連問題対応"

sla: "報告から2時間以内"

owner: "IT管理者"

\# 定期保守業務

periodic_maintenance:

weekly_tasks:

\- name: "アクセスログレビュー"

owner: "セキュリティチーム"

estimated_time: "2時間"

\- name: "システム性能分析"

owner: "SREチーム"

estimated_time: "1時間"

\- name: "新規アカウント設定"

owner: "IT管理者"

estimated_time: "可変"

monthly_tasks:

\- name: "権限利用状況分析"

owner: "セキュリティチーム"

estimated_time: "4時間"

\- name: "セキュリティポスチャ評価"

owner: "セキュリティチーム"

estimated_time: "8時間"

\- name: "コンプライアンスレポート作成"

owner: "コンプライアンス"

estimated_time: "6時間"

quarterly_tasks:

\- name: "アクセス権限認証"

owner: "各部門管理者"

estimated_time: "部門あたり4時間"

\- name: "災害復旧テスト"

owner: "SREチーム"

estimated_time: "1日"

\- name: "セキュリティ設定見直し"

owner: "セキュリティチーム"

estimated_time: "16時間"

\# 継続的改善

continuous_improvement:

performance_optimization:

\- name: "レスポンス時間最適化"

frequency: "月次"

method: "性能メトリクス分析"

\- name: "コスト最適化"

frequency: "四半期"

method: "利用状況分析・rightsizing"

\- name: "ユーザビリティ改善"

frequency: "四半期"

method: "ユーザーフィードバック分析"

security_enhancement:

\- name: "脅威ランドスケープ更新"

frequency: "月次"

method: "脅威インテリジェンス分析"

\- name: "検知ルール最適化"

frequency: "月次"

method: "偽陽性・偽陰性分析"

\- name: "新規セキュリティサービス評価"

frequency: "四半期"

method: "技術動向調査・PoC実施"

compliance_maintenance:

\- name: "規制要件更新対応"

frequency: "随時"

method: "法規制動向監視"

\- name: "内部監査対応"

frequency: "年次"

method: "監査要件準拠確認"

\- name: "外部監査対応"

frequency: "年次"

method: "第三者監査準備・対応"

9.5 成功要因と注意点

yaml

success_factors:

*\# 成功要因*

critical_success_factors:

executive_support:

importance: "最重要"

description: "経営陣の明確なサポートとリソース確保"

actions:

\- "CXOレベルでのプロジェクト承認"

\- "十分な予算・人的リソース確保"

\- "変更管理への積極的関与"

cross_functional_collaboration:

importance: "重要"

description: "部門横断的な協力体制構築"

actions:

\- "セキュリティ・IT・事業部門の連携"

\- "定期的なステークホルダー会議"

\- "明確な役割・責任分担"

phased_implementation:

importance: "重要"

description: "段階的な実装による影響最小化"

actions:

\- "パイロットアカウントでの検証"

\- "段階的ロールアウト"

\- "各フェーズでの成果確認"

user_training:

importance: "重要"

description: "十分なユーザートレーニングと支援"

actions:

\- "役割別トレーニングプログラム"

\- "充実したドキュメント"

\- "継続的なサポート体制"

*\# 注意点・リスク*

implementation_risks:

technical_risks:

\- risk: "既存システムとの統合問題"

impact: "高"

probability: "中"

mitigation: "事前の互換性検証・テスト環境での確認"

\- risk: "大規模権限変更による業務影響"

impact: "高"

probability: "中"

mitigation: "段階的移行・緊急時復旧手順準備"

\- risk: "複雑な権限設定による運用負荷増"

impact: "中"

probability: "高"

mitigation: "自動化推進・運用手順標準化"

organizational_risks:

\- risk: "ユーザーの変更への抵抗"

impact: "中"

probability: "高"

mitigation: "十分な事前説明・段階的導入"

\- risk: "スキル不足による運用品質低下"

impact: "高"

probability: "中"

mitigation: "継続的なトレーニング・外部支援活用"

\- risk: "変更管理プロセスの不備"

impact: "中"

probability: "中"

mitigation: "明確なプロセス定義・責任者設定"

security_risks:

\- risk: "移行期間中のセキュリティギャップ"

impact: "高"

probability: "中"

mitigation: "並行運用期間設定・監視強化"

\- risk: "緊急時アクセス手順の不備"

impact: "高"

probability: "低"

mitigation: "詳細な緊急時手順・定期的な訓練"

\- risk: "過度なセキュリティによる業務阻害"

impact: "中"

probability: "中"

mitigation: "ユーザビリティとセキュリティのバランス"

*\# 成功指標の設定*

kpi_framework:

security_kpis:

\- name: "セキュリティインシデント削減率"

baseline: "現状のインシデント数"

target: "50%削減"

measurement_period: "年次"

\- name: "権限過剰付与削減率"

baseline: "現状の過剰権限数"

target: "70%削減"

measurement_period: "四半期"

\- name: "コンプライアンス準拠率"

baseline: "現状の準拠率"

target: "100%"

measurement_period: "月次"

operational_kpis:

\- name: "権限管理工数削減率"

baseline: "現状の管理工数"

target: "40%削減"

measurement_period: "四半期"

\- name: "システム可用性"

baseline: "現状の可用性"

target: "99.9%以上"

measurement_period: "月次"

\- name: "平均権限付与時間"

baseline: "現状の処理時間"

target: "2時間以内"

measurement_period: "週次"

user_satisfaction_kpis:

\- name: "ユーザー満足度スコア"

baseline: "導入前の満足度"

target: "4.0/5.0以上"

measurement_period: "四半期"

\- name: "サポート問い合わせ削減率"

baseline: "現状の問い合わせ数"

target: "60%削減"

measurement_period: "月次"

\- name: "権限申請完了率"

baseline: "N/A（新指標）"

target: "95%以上"

measurement_period: "週次"

まとめ

本AWSアカウント・権限設計（基本方針）は、TechNova社の120アカウント構成における包括的な権限管理戦略を定義しています。

主要成果物

ゼロトラスト権限モデルの確立

IAM Identity Centerによる統合認証基盤

最小権限原則の徹底実装

職務分離による不正防止機能

コンプライアンス自動化システム

緊急時アクセス管理機能

包括的監視・ログシステム

事業部門別アカウント構成との統合

本方針は、既に定義された事業部門別アカウント構成の物理的な120アカウント分離構造に対し、論理的な権限管理レイヤーを提供します。両文書が相互補完することで、完全なマルチアカウント戦略が実現されます。

実装による期待効果

セキュリティリスク50%削減

権限管理工数40%削減

コンプライアンス準拠100%達成

運用効率30%向上

監査対応時間75%短縮

この包括的な権限設計により、TechNova社は安全で効率的な、そして規制要件に完全準拠したクラウド環境を実現することができます。

