# **AWSアカウント・権限設計（基本方針）**

**TechNova社の120アカウント構成における包括的権限管理戦略**

TechNova社のマルチアカウント環境における権限設計は、事業部門別アカウント構成と統合して、セキュリティ・ガバナンス・運用効率を最適化するための基本方針を定義します。本設計では、ゼロトラストセキュリティモデルを基盤とし、最小権限原則の徹底的な実装により、組織全体のセキュリティ境界を構築します。

## **概要**

**設計背景 → 包括的権限管理戦略の確立**

TechNova社の120アカウント構成における権限管理は、事業部門別アカウント構成と密接に連携し、セキュリティとガバナンスを両立させる必要があります。本方針書は、物理的なアカウント分離に対する論理的な権限管理戦略を定義します。この統合アプローチにより、各事業部門の独立性を保持しながら、組織全体のセキュリティ統制を実現できます。複雑なマルチアカウント環境において、権限の過剰付与や管理の複雑化を防ぎ、効率的な運用体制を構築することが主要な目的です。

**アカウント構成との整合性 → 事業部門別構造との完全統合**

事業部門別アカウント構成で定義された以下の構造に対応：
- **管理系アカウント** → セキュリティ、ログ、ネットワーク、請求管理を統括。中央集権的な管理により、組織全体のガバナンス統制とコンプライアンス遵守を実現
- **事業部門アカウント** → 製品開発、マーケティング、データ分析、HRの各部門に独立した権限境界を提供。部門間の権限分離により業務の独立性を保持
- **環境分離** → 本番(prod)、ステージング(staging)、開発(dev)の明確な分離。環境間の権限制御により、本番への意図しない影響を防止
- **特殊用途アカウント** → サンドボックス、共有サービスの専用管理。特別な権限要件への対応と実験環境の提供

**権限設計の目標 → セキュリティと効率性の両立**

- **Zero Trust アーキテクチャの実現** → 全てのアクセスを検証・認証し、信頼境界を明確化。継続的な信頼度評価により動的なアクセス制御を実装
- **最小権限原則の徹底** → 業務遂行に必要最小限の権限のみを付与。定期的な権限レビューと自動化された権限管理により、過剰権限を排除
- **職務分離による不正防止** → 開発・運用・監査の責任分離により内部不正を防止。相互牽制機能により権限濫用リスクを最小化
- **コンプライアンス要件への準拠** → SOC2、ISO27001、PCI DSSなどの規制要件に対応。自動化された監査証跡により継続的な準拠状態を維持
- **運用効率の向上** → 自動化された権限管理により手作業を削減。ユーザビリティを考慮した設計により生産性向上を実現

## **1. 権限設計の基本原則**

**1.1 ゼロトラストセキュリティモデル → 信頼境界の再定義**

```yaml
# Zero Trust の実装原則
zero_trust_principles:
  identity_verification:
    - "全てのアクセスを認証・認可"
    - "アカウント境界での検証強化" 
    - "継続的な信頼度評価"
  least_privilege:
    - "最小限の権限のみ付与"
    - "時間制限付きアクセス"
    - "Just-In-Time権限昇格"
  assume_breach:
    - "侵害を前提とした設計"
    - "横展開の防止"
    - "異常検知と自動対応"
```

ゼロトラストモデルは、従来のネットワーク境界防御を前提とした「内部は信頼、外部は脅威」という考え方を根本的に変革します。TechNova社の120アカウント環境では、各アカウントを独立した信頼境界として扱い、アカウント間のアクセスも含めて全てのリクエストを検証します。この実装により、一つのアカウントが侵害された場合でも、他のアカウントへの影響を最小化できます。継続的な信頼度評価では、ユーザーの行動パターン、アクセス時間、使用デバイス等を総合的に判断し、リスクレベルに応じた動的なアクセス制御を実施します。

**1.2 権限管理階層 → 多層構造による統制**

```
┌─────────────────────────────────────────────────────────────┐
│ Organization Level                                          │
│ ┌─────────────────┐ ┌─────────────────┐ ┌──────────────┐ │
│ │ Identity        │ │ Compliance      │ │ Audit        │ │
│ │ Management      │ │ Governance      │ │ Logging      │ │
│ └─────────────────┘ └─────────────────┘ └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
                           │
┌─────────────────────────────────────────────────────────────┐
│ Business Unit Level                                         │
│ ┌─────────────────┐ ┌─────────────────┐ ┌──────────────┐ │
│ │ Department      │ │ Project         │ │ Resource     │ │
│ │ Admin           │ │ Teams           │ │ Access       │ │
│ └─────────────────┘ └─────────────────┘ └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
                           │
┌─────────────────────────────────────────────────────────────┐
│ Application Level                                           │
│ ┌─────────────────┐ ┌─────────────────┐ ┌──────────────┐ │
│ │ Service         │ │ Environment     │ │ Resource     │ │
│ │ Accounts        │ │ Isolation       │ │ Specific     │ │
│ └─────────────────┘ └─────────────────┘ └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

権限管理階層は3層構造により、組織の複雑性に対応した柔軟性と統制の両立を実現します。Organization Levelでは全社的なポリシー統制とコンプライアンス要件への対応を行い、Business Unit Levelでは各事業部門の特性に応じた権限管理を実装します。Application Levelでは個別のサービスやリソースに対する詳細なアクセス制御を提供します。この階層化により、上位レベルでの統制を保持しながら、下位レベルでの柔軟な権限管理が可能となります。各レベル間の権限継承と委任機能により、効率的な権限管理体制を構築できます。

**1.3 権限付与の原則 → 最小権限と職務分離の実装**

**最小権限原則 (Principle of Least Privilege) → 必要最小限のアクセス権限**

```json
{
  "minimum_required_access": {
    "default_policy": "DENY_ALL",
    "explicit_grants": "SPECIFIC_RESOURCES_ONLY", 
    "time_bounds": "LIMITED_DURATION",
    "scope_bounds": "NARROWEST_POSSIBLE"
  },
  "progressive_access": {
    "initial_access": "READ_ONLY",
    "proven_need": "ADDITIONAL_PERMISSIONS",
    "regular_review": "ACCESS_CERTIFICATION"
  }
}
```

最小権限原則の実装では、デフォルトですべてのアクセスを拒否し、明示的に必要な権限のみを付与します。この approach により、権限の過剰付与によるセキュリティリスクを根本的に回避できます。Progressive Accessモデルでは、新規ユーザーには初期的に読み取り専用権限を付与し、業務上の必要性が証明された場合にのみ追加権限を段階的に付与します。定期的なアクセス認証プロセスにより、不要となった権限の自動的な削除と権限利用状況の継続的な監視を実現します。

**職務分離原則 (Separation of Duties) → 不正防止のための権限分離**

```yaml
separation_of_duties:
  development_vs_production:
    - "開発者は本番環境への直接アクセス不可"
    - "本番変更は承認プロセス必須"  
    - "緊急時のみ例外的な直接アクセス"
  security_vs_operations:
    - "セキュリティ設定は専門チームのみ"
    - "運用チームは日常管理のみ"
    - "相互監視による不正防止"
  audit_independence:
    - "監査ログは独立アカウントで管理"
    - "監査担当者は被監査システムにアクセス不可"
    - "ログの改ざん防止機能"
```

職務分離原則により、単一の個人が完全な制御権を持つことを防止し、内部不正のリスクを最小化します。開発・本番環境の分離では、開発者による本番環境への直接アクセスを禁止し、すべての本番変更を承認プロセス経由で実施します。セキュリティと運用の分離では、セキュリティ設定の変更権限を専門チームに限定し、運用チームは日常的な管理業務のみを担当します。監査の独立性では、監査証跡を独立したアカウントで管理し、監査担当者による対象システムへのアクセスを制限することで、監査の客観性と信頼性を確保します。

## **2. IAM Identity Center統合戦略**

**2.1 アーキテクチャ概要 → 統合認証基盤の構築**

```hcl
# IAM Identity Center の組織レベル設定
resource "aws_ssoadmin_instances" "main" {
  # Organization の管理アカウントで設定
}

# 外部IDプロバイダー統合
resource "aws_ssoadmin_instance_access_control_attributes" "main" {
  instance_arn = aws_ssoadmin_instances.main.arn
  
  attribute {
    key = "Department"
    value {
      source = ["${path:enterprise.department}"]
    }
  }
  
  attribute {
    key = "CostCenter"  
    value {
      source = ["${path:enterprise.costCenter}"]
    }
  }
  
  attribute {
    key = "JobTitle"
    value {
      source = ["${path:enterprise.title}"]
    }
  }
}
```

IAM Identity Centerは、TechNova社の120アカウント環境における統合認証基盤として機能します。組織の管理アカウントで一元設定することにより、全アカウントに対する統一的な認証・認可機能を提供し、管理の複雑性を大幅に削減できます。外部IDプロバイダーとの統合により、既存のActive DirectoryやGoogle Workspaceとの連携が可能となり、ユーザーは馴染みのある認証方式でAWSリソースにアクセスできます。属性ベースアクセス制御（ABAC）の実装により、部門・コストセンター・職位などの組織情報を活用した詳細なアクセス制御が実現されます。

**2.2 Permission Set 設計戦略 → 役割ベースアクセス制御の最適化**

**基本Permission Set階層 → 組織構造に対応した権限体系**

```yaml
permission_sets:
  # 管理系権限
  administrative:
    OrganizationAdministrator:
      description: "組織全体の管理権限"
      accounts: ["management-*"]
      policies: ["AdministratorAccess"]
      conditions:
        mfa_required: true
        session_duration: "2hours"
    SecurityAdministrator:
      description: "セキュリティ設定管理"
      accounts: ["security-*", "audit-*"]  
      policies: ["SecurityAudit", "CustomSecurityAdmin"]
      conditions:
        ip_restriction: "office_networks"
        mfa_required: true

  # 事業部門権限
  business_units:
    ProductDeveloper:
      description: "製品開発チーム"
      accounts: ["product-dev-*", "product-staging-*"]
      policies: ["EC2FullAccess", "S3Developer", "RDSReadAccess"]
      conditions:
        time_restriction: "business_hours"
    ProductionSupport:
      description: "本番環境監視・サポート"
      accounts: ["product-prod-*"]
      policies: ["CloudWatchReadOnly", "LimitedEC2Access"]
      conditions:
        approval_required: true
        max_session_duration: "4hours"

  # 環境別権限  
  environment_specific:
    DevelopmentFullAccess:
      description: "開発環境フルアクセス"
      accounts: ["*-dev-*"]
      policies: ["PowerUserAccess"]
    ProductionReadOnly:
      description: "本番環境読み取り専用"
      accounts: ["*-prod-*"]
      policies: ["ReadOnlyAccess", "SupportUser"]
```

Permission Set設計は、TechNova社の組織構造と業務要件に最適化された階層構造を採用します。管理系権限では、組織全体の統制とセキュリティ管理に必要な権限を集約し、厳格な認証要件を設定します。事業部門権限では、各部門の業務特性に応じた権限セットを提供し、部門間の権限分離を実現します。環境別権限では、開発・ステージング・本番環境の特性に応じた適切なアクセス制御を実装します。条件付きアクセス機能により、時間・場所・デバイスなどの文脈情報を考慮した動的なアクセス制御が可能となります。

**2.3 属性ベースアクセス制御 (ABAC) → 文脈情報を活用した動的制御**

```json
{
  "abac_policy_template": {
    "Version": "2012-10-17",
    "Statement": [
      {
        "Effect": "Allow",
        "Action": "*",
        "Resource": "*",
        "Condition": {
          "StringEquals": {
            "aws:PrincipalTag/Department": "${aws:RequestedRegion}",
            "ec2:ResourceTag/Environment": "${saml:Environment}",
            "s3:ResourceTag/CostCenter": "${saml:CostCenter}"
          },
          "DateGreaterThan": {
            "aws:CurrentTime": "${saml:SessionStart}"
          },
          "DateLessThan": {
            "aws:CurrentTime": "${saml:SessionEnd}"
          }
        }
      }
    ]
  }
}
```

属性ベースアクセス制御（ABAC）により、従来の役割ベースアクセス制御（RBAC）の限界を克服し、より柔軟で詳細なアクセス制御を実現します。ユーザーの部門情報、リソースのタグ情報、セッション情報を組み合わせた動的な制御により、「営業部門のユーザーは、営業部門がコストセンターとして設定されたリソースのみにアクセス可能」といった細かい制御が可能となります。時間ベースの制御により、業務時間外のアクセスを制限し、セキュリティリスクを最小化できます。この approach により、Permission Setの数を抑制しながら、複雑な組織要件に対応できます。

**2.4 外部IDプロバイダー統合 → 既存認証基盤との統合**

```hcl
# Active Directory統合
resource "aws_ssoadmin_external_identity_provider_configuration" "ad_integration" {
  instance_arn = aws_ssoadmin_instances.main.arn
  
  identity_provider_configuration {
    external_identity_provider_type = "SAML"
    saml_provider_configuration {
      metadata_document = file("${path.module}/saml/technova-ad-metadata.xml")
    }
  }
}

# Google Workspace統合 (将来対応)
resource "aws_ssoadmin_external_identity_provider_configuration" "google_workspace" {
  instance_arn = aws_ssoadmin_instances.main.arn
  
  identity_provider_configuration {
    external_identity_provider_type = "OIDC"
    oidc_provider_configuration {
      issuer_url               = "https://accounts.google.com"
      authorization_endpoint   = "https://accounts.google.com/o/oauth2/v2/auth"
      token_endpoint          = "https://oauth2.googleapis.com/token"
      userinfo_endpoint       = "https://openidconnect.googleapis.com/v1/userinfo"
      jwks_uri                = "https://www.googleapis.com/oauth2/v3/certs"
      client_id               = var.google_workspace_client_id
      client_secret           = var.google_workspace_client_secret
    }
  }
}
```

外部IDプロバイダー統合により、TechNova社の既存認証基盤を活用したシームレスなAWSアクセスが実現されます。Active Directory統合では、SAML2.0プロトコルを使用してオンプレミスのADとフェデレーション認証を構築し、既存のユーザー管理プロセスを維持できます。Google Workspace統合では、OIDC（OpenID Connect）を使用してクラウドベースの認証基盤との統合を実現します。これらの統合により、ユーザーは既存の認証情報を使用してAWSリソースにアクセスでき、パスワード管理の負担軽減とセキュリティの向上を両立できます。将来的な認証基盤の変更にも柔軟に対応可能な設計となっています。

## **3. 職務分離と最小権限の実装**

**3.1 職務分離マトリックス → 役割別権限制御の詳細定義**

```yaml
role_separation_matrix:
  # 開発チーム
  developers:
    allowed_environments: ["dev", "staging"]
    forbidden_environments: ["prod"]
    allowed_actions:
      - "ec2:*"
      - "s3:GetObject*"
      - "s3:PutObject*"
      - "rds:Describe*"
    forbidden_actions:
      - "iam:*"
      - "organizations:*"
      - "account:*"

  # インフラチーム  
  infrastructure:
    allowed_environments: ["dev", "staging", "prod"]
    allowed_actions:
      - "ec2:*"
      - "vpc:*"
      - "route53:*"
    approval_required:
      - "iam:CreateRole"
      - "iam:AttachRolePolicy"
    forbidden_actions:
      - "organizations:*"
      - "account:CloseAccount"

  # セキュリティチーム
  security:
    allowed_environments: ["all"]
    allowed_actions:
      - "iam:*"
      - "organizations:*"
      - "guardduty:*"
      - "securityhub:*"
    read_only_access:
      - "logs:*"
      - "cloudtrail:*"
```

職務分離マトリックスは、各役割に対する詳細な権限制御を定義し、内部不正や権限濫用のリスクを最小化します。開発チームは開発・ステージング環境に限定したアクセス権を持ち、本番環境への直接アクセスは禁止されています。これにより、開発作業による本番環境への意図しない影響を防止できます。インフラチームは全環境にアクセス可能ですが、重要なIAM操作には承認プロセスが必要となり、権限の不適切な拡大を防止します。セキュリティチームは組織全体のセキュリティ設定に関する権限を持ちますが、監査証跡への書き込み権限は制限され、監査の客観性を保持します。

**3.2 最小権限ポリシー実装 → 詳細なアクセス制御の技術実装**

**カスタムポリシーテンプレート → 業務要件に特化した権限定義**

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "DeveloperBaseAccess",
      "Effect": "Allow",
      "Action": [
        "ec2:Describe*",
        "ec2:List*",
        "s3:GetObject",
        "s3:PutObject"
      ],
      "Resource": "*",
      "Condition": {
        "StringEquals": {
          "aws:RequestedRegion": ["ap-northeast-1", "us-east-1"],
          "ec2:ResourceTag/Environment": ["dev", "staging"]
        },
        "IpAddress": {
          "aws:SourceIp": [
            "10.0.0.0/8",
            "172.16.0.0/12"
          ]
        }
      }
    },
    {
      "Sid": "DenyProductionAccess",
      "Effect": "Deny",
      "Action": "*",
      "Resource": "*",
      "Condition": {
        "StringEquals": {
          "ec2:ResourceTag/Environment": "prod"
        }
      }
    }
  ]
}
```

カスタムポリシーテンプレートにより、TechNova社の具体的な業務要件に対応した詳細なアクセス制御を実装します。地理的制限により、承認されたリージョンからのアクセスのみを許可し、コンプライアンス要件への対応とコスト管理を両立します。IPアドレス制限により、社内ネットワークからのアクセスのみを許可し、外部からの不正アクセスを防止します。タグベースの制御により、リソースの環境分類に基づいた自動的なアクセス制御を実現し、人的ミスを防止します。明示的なDeny文により、本番環境への意図しないアクセスを確実に阻止します。

**動的権限制御 → 文脈情報に基づく適応的アクセス管理**

```hcl
# タグベースのリソースアクセス制御
resource "aws_iam_policy" "tag_based_access" {
  name = "TagBasedResourceAccess"
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "ec2:StartInstances",
          "ec2:StopInstances", 
          "ec2:RebootInstances"
        ]
        Resource = "*"
        Condition = {
          StringEquals = {
            "ec2:ResourceTag/Owner" = "${saml:userid}"
            "ec2:ResourceTag/Department" = "${saml:department}"
          }
        }
      }
    ]
  })
}

# 時間制限付きアクセス
resource "aws_iam_policy" "time_based_access" {
  name = "TimeBasedAccess"
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "*"
        Resource = "*"
        Condition = {
          DateGreaterThan = {
            "aws:CurrentTime" = "08:00Z"
          }
          DateLessThan = {
            "aws:CurrentTime" = "18:00Z"
          }
          StringEquals = {
            "aws:RequestedRegion" = ["ap-northeast-1"]
          }
        }
      }
    ]
  })
}
```

動的権限制御により、ユーザーの属性・リソースのタグ・時間などの動的な情報を活用した適応的なアクセス管理を実現します。タグベースのリソースアクセス制御では、リソースの所有者情報とユーザーの属性を照合し、所有者のみがリソースを操作できる仕組みを構築します。時間制限付きアクセスでは、業務時間内のみのアクセスを許可し、夜間・休日のセキュリティリスクを最小化します。これらの動的制御により、静的な権限設定では対応困難な複雑な業務要件にも柔軟に対応でき、セキュリティと利便性のバランスを最適化できます。

**3.3 Just-In-Time (JIT) アクセス管理 → 一時的権限昇格システム**

```python
# JITアクセス管理Lambda関数
import boto3
import json
from datetime import datetime, timedelta

def lambda_handler(event, context):
    """
    Just-In-Time権限昇格リクエスト処理
    """
    try:
        # リクエスト情報の取得
        user_id = event['user_id']
        requested_permissions = event['permissions']
        business_justification = event['justification']
        duration_hours = event.get('duration', 2)  # デフォルト2時間

        # 承認プロセス
        approval_result = process_approval_workflow(
            user_id, requested_permissions, business_justification
        )
        
        if approval_result['approved']:
            # 一時的な権限の付与
            temp_role_arn = create_temporary_role(
                user_id, requested_permissions, duration_hours
            )
            
            # 自動削除の予約
            schedule_role_deletion(temp_role_arn, duration_hours)
            
            return {
                'statusCode': 200,
                'body': json.dumps({
                    'status': 'approved',
                    'temporary_role_arn': temp_role_arn,
                    'expires_at': (datetime.now() + timedelta(hours=duration_hours)).isoformat(),
                    'instructions': 'aws sts assume-role --role-arn ' + temp_role_arn
                })
            }
        else:
            return {
                'statusCode': 403,
                'body': json.dumps({
                    'status': 'denied',
                    'reason': approval_result['reason']
                })
            }
            
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }

def process_approval_workflow(user_id, permissions, justification):
    """
    承認ワークフローの処理
    """
    # リスクレベルの評価
    risk_level = evaluate_risk_level(permissions)
    
    if risk_level == 'LOW':
        # 自動承認
        return {'approved': True, 'reason': 'Auto-approved: Low risk'}
    elif risk_level == 'MEDIUM':
        # マネージャー承認が必要
        return initiate_manager_approval(user_id, justification)
    else:
        # 複数レベルの承認が必要
        return initiate_multi_level_approval(user_id, justification)

def create_temporary_role(user_id, permissions, duration_hours):
    """
    一時的なIAMロールの作成
    """
    iam = boto3.client('iam')
    
    # ロール名の生成
    role_name = f"TempAccess-{user_id}-{int(datetime.now().timestamp())}"
    
    # 信頼ポリシー
    assume_role_policy = {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Principal": {"AWS": f"arn:aws:iam::{boto3.client('sts').get_caller_identity()['Account']}:user/{user_id}"},
                "Action": "sts:AssumeRole",
                "Condition": {
                    "StringEquals": {
                        "sts:ExternalId": generate_external_id(user_id)
                    }
                }
            }
        ]
    }
    
    # ロール作成
    response = iam.create_role(
        RoleName=role_name,
        AssumeRolePolicyDocument=json.dumps(assume_role_policy),
        Description=f"Temporary elevated access for {user_id}",
        MaxSessionDuration=duration_hours * 3600,
        Tags=[
            {'Key': 'Purpose', 'Value': 'JIT-Access'},
            {'Key': 'User', 'Value': user_id},
            {'Key': 'ExpiresAt', 'Value': (datetime.now() + timedelta(hours=duration_hours)).isoformat()}
        ]
    )
    
    # 権限の付与
    for permission in permissions:
        iam.attach_role_policy(
            RoleName=role_name,
            PolicyArn=permission['policy_arn']
        )
    
    return response['Role']['Arn']
```

Just-In-Time（JIT）アクセス管理は、通常時は最小権限で運用し、必要時のみ一時的に権限を昇格させるセキュリティ手法です。この実装により、管理者権限などの特権アクセスを常時付与することなく、業務上必要な場合のみ制限時間付きで権限を提供できます。リスクレベルに応じた承認ワークフローにより、低リスクな権限昇格は自動承認、高リスクな場合は複数レベルの承認を要求します。一時的なIAMロールの自動作成・削除により、権限の付与と剥奪を完全に自動化し、人的ミスを排除できます。この approach により、セキュリティリスクを最小化しながら、運用の効率性を向上させることができます。

## **4. クロスアカウント権限管理**

**4.1 信頼関係設計 → アカウント間権限制御の最適化**

```yaml
cross_account_trust_model:
  # 管理アカウント → 全アカウント
  management_account:
    trust_direction: "outbound"
    trusted_accounts: ["all_organization_accounts"]
    permitted_roles:
      - "OrganizationAccountAccessRole"
      - "SecurityAuditRole"
    conditions:
      - "mfa_required: true"
      - "source_ip_restriction: office_networks"

  # セキュリティアカウント → 全アカウント（読み取り専用）
  security_account:
    trust_direction: "outbound"
    trusted_accounts: ["all_organization_accounts"]
    permitted_roles:
      - "SecurityAuditRole"
    permissions: ["read_only", "security_findings"]

  # ログアカウント → 全アカウント（ログ収集）
  logging_account:
    trust_direction: "inbound"
    trusting_accounts: ["all_organization_accounts"]
    permitted_actions:
      - "logs:CreateLogGroup"
      - "logs:CreateLogStream"
      - "logs:PutLogEvents"
```

クロスアカウント信頼関係設計は、TechNova社の120アカウント環境における統制とセキュリティのバランスを実現します。管理アカウントからの outbound trust により、組織全体のガバナンス機能を維持しながら、各アカウントの独立性を保持します。セキュリティアカウントは全アカウントに対する読み取り専用アクセスを持ち、組織全体のセキュリティ監視を実現します。ログアカウントは全アカウントからのログ収集を受け入れ、中央集権的なログ管理基盤を構築します。信頼関係の方向性を明確に定義することで、不要なアクセス経路を排除し、セキュリティリスクを最小化できます。

**4.2 クロスアカウントロールの実装 → 統一された権限管理基盤**

```hcl
# 組織レベルでのクロスアカウントロール
resource "aws_iam_role" "cross_account_security_audit" {
  for_each = toset(var.organization_account_ids)
  name     = "CrossAccountSecurityAudit"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::${var.security_account_id}:root"
        }
        Action = "sts:AssumeRole"
        Condition = {
          StringEquals = {
            "sts:ExternalId" = var.cross_account_external_id
          }
          Bool = {
            "aws:MultiFactorAuthPresent" = "true"
          }
          IpAddress = {
            "aws:SourceIp" = var.allowed_ip_ranges
          }
        }
      }
    ]
  })
  
  tags = {
    Purpose   = "Cross-Account Security Audit"
    ManagedBy = "Terraform"
  }
}

# セキュリティ監査用の統一ポリシー
resource "aws_iam_role_policy_attachment" "security_audit_policy" {
  for_each   = toset(var.organization_account_ids)
  role       = aws_iam_role.cross_account_security_audit[each.key].name
  policy_arn = "arn:aws:iam::aws:policy/SecurityAudit"
}

# カスタムセキュリティポリシー
resource "aws_iam_role_policy" "custom_security_audit" {
  for_each = toset(var.organization_account_ids)
  name     = "CustomSecurityAuditPolicy"
  role     = aws_iam_role.cross_account_security_audit[each.key].id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "access-analyzer:List*",
          "access-analyzer:Get*",
          "guardduty:List*",
          "guardduty:Get*",
          "securityhub:List*",
          "securityhub:Get*",
          "config:List*",
          "config:Get*",
          "config:Describe*"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "s3:GetBucketPolicy",
          "s3:GetBucketAcl",
          "s3:GetBucketPublicAccessBlock"
        ]
        Resource = "*"
      }
    ]
  })
}
```

クロスアカウントロールの実装により、120アカウント環境全体で統一されたセキュリティ監査機能を提供します。Terraformのfor_each機能を活用し、全アカウントに同一のセキュリティロールを自動デプロイし、設定の一貫性を保証します。External IDとMFA要件により、アカウント間のアクセスにおいても強固な認証を実現します。IPアドレス制限により、許可されたネットワークからのアクセスのみを受け入れ、外部からの不正アクセスを防止します。カスタムポリシーにより、AWSマネージドポリシーでは対応できない固有の要件にも対応し、包括的なセキュリティ監査機能を実現します。

**4.3 アカウント間通信制御 → ネットワークレベルでのセキュリティ強化**

```hcl
# VPC エンドポイントポリシー（アカウント間制限）
resource "aws_vpc_endpoint_policy" "s3_cross_account_policy" {
  vpc_endpoint_id = aws_vpc_endpoint.s3.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = "*"
        Action = [
          "s3:GetObject",
          "s3:PutObject"
        ]
        Resource = "*"
        Condition = {
          StringEquals = {
            "aws:PrincipalAccount" = var.trusted_account_ids
          }
        }
      },
      {
        Effect = "Deny"
        Principal = "*"
        Action = "*"
        Resource = "*"
        Condition = {
          StringNotEquals = {
            "aws:PrincipalAccount" = var.trusted_account_ids
          }
        }
      }
    ]
  })
}

# リソースベースポリシー例（S3バケット）
resource "aws_s3_bucket_policy" "cross_account_access" {
  bucket = aws_s3_bucket.shared_resources.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "CrossAccountAccess"
        Effect = "Allow"
        Principal = {
          AWS = [
            for account_id in var.trusted_account_ids :
            "arn:aws:iam::${account_id}:root"
          ]
        }
        Action = [
          "s3:GetObject",
          "s3:PutObject"
        ]
        Resource = "${aws_s3_bucket.shared_resources.arn}/*"
        Condition = {
          StringEquals = {
            "s3:x-amz-server-side-encryption" = "aws:kms"
          }
          Bool = {
            "aws:SecureTransport" = "true"
          }
        }
      }
    ]
  })
}
```

アカウント間通信制御により、ネットワークレベルでのセキュリティ強化を実現します。VPCエンドポイントポリシーでは、信頼されたアカウントからのアクセスのみを許可し、未承認のアカウントからの通信を確実に遮断します。リソースベースポリシーでは、暗号化とHTTPS通信の強制により、データの機密性と完全性を保護します。明示的なDeny文により、条件に合致しないアクセスを確実に拒否し、セキュリティホールを防止します。この多層防御 approach により、アカウント間での必要最小限の通信のみを許可し、lateral movement攻撃のリスクを最小化できます。

## **5. コンプライアンス・監査対応**

**5.1 法的要件への対応 → 包括的コンプライアンスフレームワーク**

```yaml
compliance_frameworks:
  # SOC 2 Type II
  soc2_type2:
    requirements:
      - "アクセス制御の文書化"
      - "権限変更の承認プロセス"
      - "定期的なアクセスレビュー"
      - "特権アクセスの監視"
    implementation:
      access_control_documentation: "IAM Policy文書化"
      approval_process: "ServiceNow統合ワークフロー"
      periodic_review: "四半期アクセス認証"
      privileged_monitoring: "CloudTrail + GuardDuty"

  # ISO 27001
  iso27001:
    requirements:
      - "情報セキュリティ管理システム(ISMS)"
      - "リスクアセスメントとリスク処理"
      - "アクセス管理"
      - "暗号化"
    implementation:
      isms: "AWS Config Rules + Security Hub"
      risk_assessment: "AWS Well-Architected Framework"
      access_management: "IAM Identity Center + Access Analyzer"
      encryption: "KMS + CloudTrail暗号化"

  # PCI DSS (カード決済関連)
  pci_dss:
    scope: "決済処理アカウント"
    requirements:
      - "カード会員データへのアクセス制限"
      - "一意のユーザーIDの割り当て"
      - "物理的・論理的アクセスの制限"
      - "ネットワークリソースとCADへのアクセス監視"
    implementation:
      data_access_restriction: "専用VPC + セキュリティグループ"
      unique_user_id: "IAM Identity Center強制"
      access_restriction: "MFA + IP制限"
      monitoring: "VPC Flow Logs + GuardDuty"
```

コンプライアンスフレームワークは、TechNova社が対応すべき主要な規制要件を体系的に整理し、技術的な実装方法を明確化します。SOC 2 Type IIでは、アクセス制御の運用有効性を証明するため、継続的な監視と定期的なレビュープロセスを自動化します。ISO 27001では、情報セキュリティ管理システム全体の統制を実現するため、AWS Configとの統合により継続的なコンプライアンス監視を実装します。PCI DSSでは、カード決済データを扱う特定アカウントに対して、より厳格なアクセス制御と監視を適用します。これらのフレームワークの統合実装により、複数の規制要件への同時対応と監査コストの削減を実現できます。

**5.2 コンプライアンス監視の自動化 → 継続的な準拠状態の維持**

```hcl
# AWS Config Rules for コンプライアンス監視
resource "aws_config_configuration_recorder" "compliance_recorder" {
  name     = "TechNovaComplianceRecorder"
  role_arn = aws_iam_role.config_role.arn

  recording_group {
    all_supported                 = true
    include_global_resource_types = true
  }
}

# SOC 2コンプライアンス用Config Rules
resource "aws_config_config_rule" "soc2_mfa_enabled" {
  name = "soc2-mfa-enabled-for-console-access"

  source {
    owner             = "AWS"
    source_identifier = "MFA_ENABLED_FOR_ROOT"
  }

  depends_on = [aws_config_configuration_recorder.compliance_recorder]
}

resource "aws_config_config_rule" "soc2_password_policy" {
  name = "soc2-iam-password-policy"

  source {
    owner             = "AWS"
    source_identifier = "IAM_PASSWORD_POLICY"
  }

  input_parameters = jsonencode({
    RequireUppercaseCharacters = "true"
    RequireLowercaseCharacters = "true"
    RequireSymbols            = "true"
    RequireNumbers            = "true"
    MinimumPasswordLength     = "14"
    PasswordReusePrevention   = "12"
    MaxPasswordAge            = "90"
  })
}

# ISO 27001コンプライアンス用Rules
resource "aws_config_config_rule" "iso27001_encryption_at_rest" {
  name = "iso27001-s3-bucket-server-side-encryption-enabled"

  source {
    owner             = "AWS"
    source_identifier = "S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED"
  }
}

# PCI DSSコンプライアンス用Rules（決済処理アカウント）
resource "aws_config_config_rule" "pci_dss_security_groups" {
  count = contains(var.pci_scope_accounts, data.aws_caller_identity.current.account_id) ? 1 : 0
  name  = "pci-dss-security-groups-restricted"

  source {
    owner             = "AWS"
    source_identifier = "INCOMING_SSH_DISABLED"
  }
}

resource "aws_config_config_rule" "pci_dss_root_access_key" {
  count = contains(var.pci_scope_accounts, data.aws_caller_identity.current.account_id) ? 1 : 0
  name  = "pci-dss-root-access-key-check"

  source {
    owner             = "AWS"
    source_identifier = "ROOT_ACCESS_KEY_CHECK"
  }
}
```

AWS Configを活用したコンプライアンス監視の自動化により、継続的な準拠状態の維持を実現します。設定レコーダーにより、全てのリソース設定変更を記録し、コンプライアンス違反の迅速な検出を可能にします。SOC 2用のルールでは、MFA設定やパスワードポリシーの遵守状況を自動監視し、Trust Services Criteriaへの準拠を確保します。ISO 27001用のルールでは、暗号化設定などの技術的統制の実装状況を継続的に検証します。PCI DSS用のルールでは、カード決済処理に関わる環境に対してより厳格な監視を実装し、Payment Card Industry基準への準拠を保証します。条件付きリソース作成により、対象アカウントでのみ必要なルールを適用し、効率的な監視体制を構築できます。

**5.3 監査証跡の設計 → 包括的な監査ログ管理**

```hcl
# 組織レベルのCloudTrail設定
resource "aws_cloudtrail" "organization_trail" {
  name           = "TechNova-Organization-AuditTrail"
  s3_bucket_name = aws_s3_bucket.audit_logs.bucket
  
  # 組織全体のイベントを記録
  is_organization_trail = true
  is_multi_region_trail = true
  
  # データイベントの記録
  event_selector {
    read_write_type                 = "All"
    include_management_events       = true
    exclude_management_event_sources = []
    
    data_resource {
      type   = "AWS::S3::Object"
      values = ["arn:aws:s3:::*/sensitive-data/*"]
    }
    
    data_resource {
      type   = "AWS::KMS::Key"
      values = ["*"]
    }
  }
  
  # 洞察セレクター（異常検知）
  insight_selector {
    insight_type = "ApiCallRateInsight"
  }
  
  tags = {
    Purpose     = "Compliance Audit Trail"
    Compliance  = "SOC2,ISO27001,PCI-DSS"
  }
}

# 監査ログ用S3バケット
resource "aws_s3_bucket" "audit_logs" {
  bucket = "technova-audit-logs-${random_id.audit_suffix.hex}"
  
  tags = {
    Purpose     = "Audit Log Storage"
    Retention   = "7years"
    Compliance  = "SOC2,ISO27001"
  }
}

resource "aws_s3_bucket_lifecycle_configuration" "audit_logs_lifecycle" {
  bucket = aws_s3_bucket.audit_logs.id

  rule {
    id     = "audit_log_retention"
    status = "Enabled"

    # 90日後にIA移行
    transition {
      days          = 90
      storage_class = "STANDARD_IA"
    }

    # 1年後にGlacier移行
    transition {
      days          = 365
      storage_class = "GLACIER"
    }

    # 7年後にDeep Archive移行
    transition {
      days          = 2555  # 7年
      storage_class = "DEEP_ARCHIVE"
    }

    # 10年後に削除
    expiration {
      days = 3650  # 10年
    }
  }
}

# 監査ログへの不正アクセス防止
resource "aws_s3_bucket_policy" "audit_logs_policy" {
  bucket = aws_s3_bucket.audit_logs.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "DenyDirectAccess"
        Effect = "Deny"
        Principal = "*"
        Action    = "s3:*"
        Resource = [
          aws_s3_bucket.audit_logs.arn,
          "${aws_s3_bucket.audit_logs.arn}/*"
        ]
        Condition = {
          StringNotEquals = {
            "aws:PrincipalServiceName" = [
              "cloudtrail.amazonaws.com",
              "config.amazonaws.com"
            ]
          }
          StringNotLike = {
            "aws:PrincipalArn" = [
              "arn:aws:iam::${var.audit_account_id}:role/AuditRole*"
            ]
          }
        }
      },
      {
        Sid    = "AllowAuditAccountReadOnly"
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::${var.audit_account_id}:root"
        }
        Action = [
          "s3:GetObject",
          "s3:ListBucket"
        ]
        Resource = [
          aws_s3_bucket.audit_logs.arn,
          "${aws_s3_bucket.audit_logs.arn}/*"
        ]
        Condition = {
          Bool = {
            "aws:MultiFactorAuthPresent" = "true"
          }
        }
      }
    ]
  })
}
```

監査証跡設計は、TechNova社の包括的な監査要件に対応した長期保存と高可用性を実現します。組織レベルのCloudTrail設定により、120アカウント全体のAPI呼び出しを統一的に記録し、監査の網羅性を保証します。データイベントの詳細記録により、機密データへのアクセスやKMSキーの使用状況を追跡できます。インサイトセレクターによる異常検知機能により、通常パターンから逸脱したAPI呼び出しを自動的に特定し、潜在的な脅威を早期発見します。ライフサイクル設定による自動的なストレージクラス移行により、長期保存要件を満たしながらコストを最適化します。厳格なアクセス制御により、監査ログの改ざんや不正アクセスを防止し、監査証跡の信頼性を確保します。

## **6. セキュリティ境界設計**

**6.1 多層防御アーキテクチャ → 包括的セキュリティ戦略**

```yaml
security_layers:
  # レイヤー1: 物理的境界（アカウント分離）
  account_isolation:
    principle: "完全な論理分離"
    implementation: "AWS Organizations + SCP"
    scope: "120アカウント構成"

  # レイヤー2: ネットワーク境界
  network_isolation:
    principle: "ゼロトラストネットワーク"
    implementation: "VPC + Security Groups + NACLs"
    scope: "VPC間通信制御"

  # レイヤー3: アプリケーション境界
  application_isolation:
    principle: "マイクロセグメンテーション"
    implementation: "IAM + Resource Tags + Policies"
    scope: "リソースレベルアクセス制御"

  # レイヤー4: データ境界
  data_isolation:
    principle: "暗号化とアクセス制御"
    implementation: "KMS + S3 Bucket Policies + Database Security"
    scope: "データレベル保護"
```

多層防御アーキテクチャは、複数のセキュリティ境界を組み合わせた包括的な防御戦略を実現します。アカウント分離レイヤーでは、AWS Organizationsによる物理的な境界により、最も基本的な分離を実現し、一つのアカウントへの侵害が他のアカウントに波及することを防止します。ネットワーク分離レイヤーでは、VPCとセキュリティグループによる詳細な通信制御により、必要最小限のネットワーク接続のみを許可します。アプリケーション分離レイヤーでは、IAMとリソースタグを活用したマイクロセグメンテーションにより、アプリケーション単位での精密なアクセス制御を実装します。データ分離レイヤーでは、暗号化と詳細なアクセス制御により、最終的なデータ保護を実現します。これらの多層防御により、single point of failureを排除し、攻撃者による lateral movement を効果的に阻止できます。

## **7. 緊急時アクセス管理**

**7.1 Break Glass アクセス設計 → 緊急時対応体制の構築**

```hcl
# 緊急時アクセス用のIAMロール
resource "aws_iam_role" "emergency_access_role" {
  name = "EmergencyBreakGlassRole"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          AWS = [
            for user in var.emergency_access_users :
            "arn:aws:iam::${data.aws_caller_identity.current.account_id}:user/${user}"
          ]
        }
        Action = "sts:AssumeRole"
        Condition = {
          Bool = {
            "aws:MultiFactorAuthPresent" = "true"
          }
          StringEquals = {
            "sts:ExternalId" = var.emergency_external_id
          }
          IpAddress = {
            "aws:SourceIp" = var.emergency_access_ips
          }
        }
      }
    ]
  })
  
  # セッション期間を1時間に制限
  max_session_duration = 3600
  
  tags = {
    Purpose      = "Emergency Break Glass Access"
    CriticalRole = "true"
  }
}

# 緊急時用のポリシー（制限付きAdministratorAccess）
resource "aws_iam_role_policy" "emergency_access_policy" {
  name = "EmergencyAccessPolicy"
  role = aws_iam_role.emergency_access_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect   = "Allow"
        Action   = "*"
        Resource = "*"
        Condition = {
          StringNotEquals = {
            "aws:PrincipalServiceName" = [
              "organizations.amazonaws.com",
              "account.amazonaws.com"
            ]
          }
        }
      },
      {
        Effect = "Deny"
        Action = [
          "organizations:*",
          "account:CloseAccount",
          "iam:DeleteRole",
          "iam:DeleteUser"
        ]
        Resource = "*"
      }
    ]
  })
}
```

Break Glassアクセス設計は、システム障害や緊急事態において迅速な対応を可能にする一方で、セキュリティリスクを最小化する仕組みです。限定されたユーザーのみが使用可能な緊急時ロールを定義し、MFA・External ID・IP制限による多要素認証を必須とします。セッション時間を1時間に制限することで、緊急時アクセスの濫用を防止し、必要最小限の期間での使用に限定します。組織設定やアカウント削除などの破壊的操作を明示的に禁止することで、緊急時であっても重要な統制機能を維持します。この設計により、ビジネス継続性とセキュリティ統制の両立を実現できます。

**7.2 緊急時アクセス監視システム → リアルタイム検知と対応**

```python
# 緊急時アクセス監視Lambda関数
import boto3
import json
import os
from datetime import datetime

def lambda_handler(event, context):
    """
    Break Glassロールの使用を監視・通知
    """
    try:
        # CloudTrailイベントから緊急時アクセスを検出
        records = event.get('Records', [])
        for record in records:
            if 'cloudtrail' in record.get('eventSource', '').lower():
                cloudtrail_data = json.loads(record['body'])
                
                # AssumeRoleイベントの確認
                if cloudtrail_data.get('eventName') == 'AssumeRole':
                    role_arn = cloudtrail_data.get('responseElements', {}).get('assumedRoleUser', {}).get('arn', '')
                    
                    # Break Glassロールの使用検出
                    if 'EmergencyBreakGlassRole' in role_arn:
                        handle_emergency_access_event(cloudtrail_data)
                        
    except Exception as e:
        print(f"Error processing emergency access event: {str(e)}")
        send_error_notification(str(e))
    
    return {'statusCode': 200}

def handle_emergency_access_event(event_data):
    """
    緊急時アクセスイベントの処理
    """
    # イベント詳細の抽出
    user_identity = event_data.get('userIdentity', {})
    source_ip = event_data.get('sourceIPAddress', 'Unknown')
    event_time = event_data.get('eventTime', datetime.now().isoformat())
    user_name = user_identity.get('userName', 'Unknown')
    mfa_used = event_data.get('requestContext', {}).get('mfaAuthenticated', False)
    
    # セキュリティ情報の収集
    security_context = {
        'user_name': user_name,
        'source_ip': source_ip,
        'event_time': event_time,
        'mfa_authenticated': mfa_used,
        'user_agent': event_data.get('userAgent', 'Unknown'),
        'aws_region': event_data.get('awsRegion', 'Unknown')
    }
    
    # DynamoDBに記録
    record_emergency_access(security_context)
    
    # 即座に通知送信
    send_emergency_access_alert(security_context)
    
    # 追加の監視開始
    initiate_enhanced_monitoring(user_name, source_ip)

def send_emergency_access_alert(security_context):
    """
    緊急時アクセスアラートの送信
    """
    sns = boto3.client('sns')
    
    # アラートメッセージの作成
    alert_message = f"""
🚨 CRITICAL: Emergency Break Glass Access Detected 🚨

User: {security_context['user_name']}
Time: {security_context['event_time']}
Source IP: {security_context['source_ip']}
MFA Used: {'Yes' if security_context['mfa_authenticated'] else 'No'}
User Agent: {security_context['user_agent']}
Region: {security_context['aws_region']}

This is an automated alert for emergency administrative access.
Immediate investigation required.

Security Dashboard: https://console.aws.amazon.com/securityhub/
CloudTrail Logs: https://console.aws.amazon.com/cloudtrail/
"""
    
    # 複数チャネルに通知
    notification_topics = [
        os.environ['SECURITY_ALERTS_TOPIC'],
        os.environ['EMERGENCY_ALERTS_TOPIC']
    ]
    
    for topic_arn in notification_topics:
        try:
            sns.publish(
                TopicArn=topic_arn,
                Subject="🚨 EMERGENCY: Break Glass Access Detected",
                Message=alert_message
            )
        except Exception as e:
            print(f"Failed to send alert to {topic_arn}: {str(e)}")
```

緊急時アクセス監視システムは、Break Glassロールの使用を即座に検知し、リアルタイムでセキュリティチームに通知する仕組みです。CloudTrailイベントをリアルタイムで監視し、緊急時ロールのAssumeRole操作を自動検出します。セキュリティコンテキスト情報（ユーザー・IP・時刻・MFA使用状況など）を詳細に記録し、後の調査に必要な証跡を確保します。複数の通知チャネルを使用した冗長な警告システムにより、重要な緊急時アクセスが見逃されることを防止します。強化監視機能により、緊急時アクセス後の一定期間、該当ユーザーの活動を詳細に監視し、不正な権限使用を早期に発見できます。

**7.3 緊急時プロシージャ → 段階的対応体制の確立**

```yaml
emergency_procedures:
  # レベル1: サービス障害対応
  service_outage:
    trigger: "重要サービスの完全停止"
    response_time: "15分以内"
    authorized_personnel:
      - "SREチームリーダー"
      - "ITマネージャー"
    access_scope: "影響を受けたサービスのアカウントのみ"
    approval_process: "口頭承認 + 事後報告"

  # レベル2: セキュリティインシデント
  security_incident:
    trigger: "セキュリティ侵害の疑い"
    response_time: "5分以内"
    authorized_personnel:
      - "CISOまたは代理"
      - "セキュリティチームリーダー"
    access_scope: "全アカウント（必要に応じて）"
    approval_process: "CISO承認 + リアルタイム監視"

  # レベル3: 法的・規制対応
  legal_compliance:
    trigger: "法執行機関からの要請"
    response_time: "状況に応じて"
    authorized_personnel:
      - "法務部長"
      - "コンプライアンス責任者"
      - "CEO承認済み担当者"
    access_scope: "要請対象のアカウント・データのみ"
    approval_process: "CEO + 法務部長の書面承認"

emergency_access_matrix:
  break_glass_levels:
    level_1_service_recovery:
      max_duration: "2時間"
      required_approvals: 1
      post_incident_review: "24時間以内"
      automatic_revocation: true

    level_2_security_response:
      max_duration: "4時間"
      required_approvals: 2
      post_incident_review: "12時間以内"
      automatic_revocation: true
      continuous_monitoring: true

    level_3_legal_compliance:
      max_duration: "状況に応じて"
      required_approvals: 3
      post_incident_review: "即時"
      automatic_revocation: false
      legal_documentation: true

post_emergency_procedures:
  immediate_actions:
    - "アクセス終了の確認"
    - "実行されたアクションの記録"
    - "関係者への報告"

  documentation_requirements:
    - "緊急時アクセス理由書"
    - "実行されたコマンド・変更のログ"
    - "インシデント対応レポート"
    - "改善提案書"

  review_process:
    - "48時間以内のレビュー会議"
    - "根本原因分析"
    - "プロセス改善の検討"
    - "必要に応じた権限見直し"
```

緊急時プロシージャは、インシデントの重要度に応じた段階的な対応体制を確立し、迅速な問題解決とセキュリティ統制の両立を実現します。サービス障害対応では、ビジネス影響を最小化するための迅速なアクセス承認プロセスを提供し、事後の適切な監査証跡確保を義務付けます。セキュリティインシデント対応では、より厳格な承認プロセスと継続的な監視により、インシデント拡大の防止と証拠保全を両立します。法的対応では、最高レベルの承認と完全な文書化により、法的要件への適切な対応を保証します。事後レビュープロセスにより、各緊急時アクセスから学習し、継続的なプロセス改善を実現できます。

## **8. 監視・ログ戦略**

**8.1 包括的監視アーキテクチャ → 多角的セキュリティ監視**

```hcl
# AWS Config - 設定変更監視
resource "aws_config_configuration_recorder" "security_recorder" {
  name     = "TechNova-Security-Configuration-Recorder"
  role_arn = aws_iam_role.config_recorder_role.arn

  recording_group {
    all_supported                 = true
    include_global_resource_types = true
    
    # 重要なリソースタイプを明示的に指定
    resource_types = [
      "AWS::IAM::Role",
      "AWS::IAM::Policy", 
      "AWS::IAM::User",
      "AWS::S3::Bucket",
      "AWS::KMS::Key",
      "AWS::EC2::SecurityGroup",
      "AWS::Organizations::Account"
    ]
  }

  depends_on = [aws_config_delivery_channel.security_channel]
}

# GuardDuty - 脅威検出
resource "aws_guardduty_detector" "main" {
  enable = true
  
  # S3保護の有効化
  datasources {
    s3_logs {
      enable = true
    }
    kubernetes {
      audit_logs {
        enable = true
      }
    }
    malware_protection {
      scan_ec2_instance_with_findings {
        ebs_volumes {
          enable = true
        }
      }
    }
  }

  tags = {
    Purpose     = "Threat Detection"
    Environment = "Organization"
  }
}

# Security Hub - 統合セキュリティ監視
resource "aws_securityhub_account" "main" {
  enable_default_standards = true
}

# CloudWatch メトリクスフィルター - 重要なIAMイベント
resource "aws_cloudwatch_log_metric_filter" "root_usage" {
  name           = "RootAccountUsage"
  log_group_name = aws_cloudwatch_log_group.cloudtrail.name
  pattern        = "{ $.userIdentity.type = \"Root\" && $.userIdentity.invokedBy NOT EXISTS && $.eventType != \"AwsServiceEvent\" }"

  metric_transformation {
    name      = "RootAccountUsageCount"
    namespace = "TechNova/Security"
    value     = "1"
  }
}

resource "aws_cloudwatch_log_metric_filter" "iam_policy_changes" {
  name           = "IAMPolicyChanges"
  log_group_name = aws_cloudwatch_log_group.cloudtrail.name
  pattern        = "{ ($.eventName = CreatePolicy) || ($.eventName = DeletePolicy) || ($.eventName = CreatePolicyVersion) || ($.eventName = DeletePolicyVersion) || ($.eventName = AttachRolePolicy) || ($.eventName = DetachRolePolicy) }"

  metric_transformation {
    name      = "IAMPolicyChangesCount"
    namespace = "TechNova/Security"
    value     = "1"
  }
}
```

包括的監視アーキテクチャは、複数のAWSセキュリティサービスを統合し、多角的な脅威検出と設定監視を実現します。AWS Configによる設定変更監視では、重要なリソースタイプに特化した継続的な記録により、セキュリティ設定の逸脱を即座に検出します。GuardDutyによる脅威検出では、機械学習を活用した異常検知により、従来の署名ベース検知では発見困難な新種の脅威も検出可能です。Security Hubによる統合監視では、複数のセキュリティサービスからの検出結果を一元管理し、セキュリティチームの運用効率を向上させます。CloudWatchメトリクスフィルターにより、ログデータから重要なセキュリティイベントを抽出し、リアルタイムでの監視・アラート機能を提供します。

**8.2 リアルタイム脅威検出 → 自動化された脅威対応**

```python
# リアルタイム脅威検出Lambda関数
import boto3
import json
import os
from datetime import datetime

class ThreatDetectionEngine:
    def __init__(self):
        self.guardduty = boto3.client('guardduty')
        self.securityhub = boto3.client('securityhub')
        self.sns = boto3.client('sns')
        self.dynamodb = boto3.resource('dynamodb')
        self.threat_table = self.dynamodb.Table(os.environ['THREAT_DETECTION_TABLE'])

    def process_security_event(self, event):
        """
        セキュリティイベントの処理
        """
        try:
            # イベントソースの判定
            if 'guardduty' in event.get('source', '').lower():
                return self.handle_guardduty_finding(event)
            elif 'securityhub' in event.get('source', '').lower():
                return self.handle_securityhub_finding(event)
            elif 'cloudtrail' in event.get('source', '').lower():
                return self.handle_cloudtrail_event(event)
            else:
                return self.handle_generic_security_event(event)
                
        except Exception as e:
            print(f"Error processing security event: {str(e)}")
            return {'statusCode': 500, 'error': str(e)}

    def handle_guardduty_finding(self, event):
        """
        GuardDuty脅威検出の処理
        """
        detail = event.get('detail', {})
        finding_id = detail.get('id', 'unknown')
        severity = detail.get('severity', 0)
        finding_type = detail.get('type', 'Unknown')
        
        # 脅威レベルの判定
        threat_level = self.determine_threat_level(severity, finding_type)
        
        # 脅威情報の記録
        threat_record = {
            'finding_id': finding_id,
            'source': 'GuardDuty',
            'type': finding_type,
            'severity': severity,
            'threat_level': threat_level,
            'timestamp': datetime.now().isoformat(),
            'account_id': detail.get('accountId', 'unknown'),
            'region': detail.get('region', 'unknown'),
            'resource': detail.get('resource', {}),
            'evidence': detail.get('service', {}).get('evidence', {})
        }
        
        self.store_threat_record(threat_record)
        
        # 自動対応の実行
        if threat_level in ['CRITICAL', 'HIGH']:
            self.initiate_automated_response(threat_record)
        
        # 通知送信
        self.send_threat_notification(threat_record)
        
        return {'statusCode': 200, 'threat_level': threat_level}

    def initiate_automated_response(self, threat_record):
        """
        自動対応の実行
        """
        finding_type = threat_record['type']
        resource = threat_record.get('resource', {})
        
        try:
            # EC2インスタンス関連の脅威
            if 'EC2' in resource.get('resourceType', ''):
                instance_id = resource.get('instanceDetails', {}).get('instanceId')
                if instance_id:
                    self.isolate_ec2_instance(instance_id, threat_record['account_id'])
            
            # IAM関連の脅威
            elif 'IAMUser' in resource.get('resourceType', ''):
                user_name = resource.get('accessKeyDetails', {}).get('userName')
                if user_name:
                    self.disable_iam_user(user_name, threat_record['account_id'])
            
            # S3関連の脅威
            elif 'S3Bucket' in resource.get('resourceType', ''):
                bucket_name = resource.get('s3BucketDetails', [{}])[0].get('name')
                if bucket_name:
                    self.secure_s3_bucket(bucket_name, threat_record['account_id'])
                    
        except Exception as e:
            print(f"Automated response failed: {str(e)}")
            # 自動対応失敗の通知
            self.send_response_failure_alert(threat_record, str(e))

    def isolate_ec2_instance(self, instance_id, account_id):
        """
        EC2インスタンスの隔離
        """
        # クロスアカウントロールでターゲットアカウントにアクセス
        assumed_role = self.assume_security_role(account_id)
        ec2 = boto3.client('ec2',
            aws_access_key_id=assumed_role['AccessKeyId'],
            aws_secret_access_key=assumed_role['SecretAccessKey'],
            aws_session_token=assumed_role['SessionToken']
        )
        
        try:
            # 隔離用セキュリティグループの作成/取得
            isolation_sg = self.get_or_create_isolation_security_group(ec2)
            
            # インスタンスのセキュリティグループを隔離用に変更
            ec2.modify_instance_attribute(
                InstanceId=instance_id,
                Groups=[isolation_sg['GroupId']]
            )
            
            # インスタンスにタグ付け
            ec2.create_tags(
                Resources=[instance_id],
                Tags=[
                    {'Key': 'SecurityStatus', 'Value': 'ISOLATED'},
                    {'Key': 'IsolationReason', 'Value': 'GuardDuty_Threat_Detection'},
                    {'Key': 'IsolationTime', 'Value': datetime.now().isoformat()}
                ]
            )
            
            print(f"Successfully isolated EC2 instance: {instance_id}")
            
        except Exception as e:
            print(f"Failed to isolate EC2 instance {instance_id}: {str(e)}")
            raise
```

リアルタイム脅威検出システムは、複数のセキュリティイベントソースを統合し、脅威レベルに応じた自動化された対応を実現します。GuardDutyの機械学習ベース検出と組み合わせ、従来の手動対応では間に合わない高速な脅威に対する即座の対応を可能にします。脅威レベルの自動判定により、重要度の高い脅威に対してリソースを集中し、効率的なセキュリティ運用を実現します。EC2インスタンスの自動隔離、IAMユーザーの無効化、S3バケットの保護など、脅威タイプに応じた適切な自動対応により、被害の拡大を防止します。詳細な監査証跡と通知機能により、自動対応の透明性を確保し、後の調査・分析に必要な情報を提供します。

## **9. 実装ガイドライン**

**9.1 フェーズ別実装計画 → 段階的導入戦略**

```yaml
implementation_phases:
  # フェーズ1: 基盤構築（1-2ヶ月）
  phase_1_foundation:
    duration: "8週間"
    objectives:
      - "IAM Identity Center設定"
      - "基本Permission Set作成"
      - "CloudTrail・Config設定"
      - "基本監視の実装"
    deliverables:
      - "Identity Center統合完了"
      - "基本権限体系構築"
      - "監査ログ基盤構築"
    success_criteria:
      - "全アカウントでSSO認証可能"
      - "監査ログ100%取得"
      - "基本セキュリティアラート動作"

  # フェーズ2: 権限最適化（2-3ヶ月）
  phase_2_optimization:
    duration: "6週間"
    objectives:
      - "最小権限ポリシー実装"
      - "ABAC導入"
      - "JITアクセス実装"
      - "クロスアカウント権限最適化"
    deliverables:
      - "カスタムPermission Set完了"
      - "JITアクセス機能稼働"
      - "権限認証プロセス確立"
    success_criteria:
      - "過剰権限50%削減"
      - "JITアクセス利用率80%"
      - "権限認証プロセス100%遵守"

  # フェーズ3: 高度なセキュリティ（3-4ヶ月）
  phase_3_advanced_security:
    duration: "6週間"
    objectives:
      - "脅威検出システム完全実装"
      - "自動対応機能実装"
      - "Break Glassプロセス確立"
      - "コンプライアンス自動化"
    deliverables:
      - "脅威検出・対応システム稼働"
      - "緊急時アクセス体制確立"
      - "コンプライアンス監視自動化"
    success_criteria:
      - "脅威検出率95%以上"
      - "自動対応時間5分以内"
      - "コンプライアンス準拠率100%"

  # フェーズ4: 運用最適化（継続）
  phase_4_optimization:
    duration: "継続的"
    objectives:
      - "運用プロセス最適化"
      - "性能監視・改善"
      - "セキュリティポスチャ向上"
      - "ユーザビリティ改善"
    deliverables:
      - "運用手順書完備"
      - "性能ベンチマーク確立"
      - "継続的改善プロセス"
    success_criteria:
      - "運用効率20%向上"
      - "ユーザー満足度90%以上"
      - "セキュリティインシデント0件"
```

フェーズ別実装計画は、複雑な権限管理システムを段階的に導入し、リスクを最小化しながら確実な成果を実現します。基盤構築フェーズでは、IAM Identity Centerを中核とした統合認証基盤を確立し、基本的な監視・ログ機能を実装します。権限最適化フェーズでは、最小権限原則の徹底実装とABACによる詳細制御を導入し、JITアクセスによる動的な権限管理を実現します。高度なセキュリティフェーズでは、自動化された脅威検出・対応システムを実装し、緊急時対応体制を確立します。運用最適化フェーズでは、継続的な改善プロセスにより、長期的なセキュリティポスチャの向上を実現します。各フェーズの明確な成功基準により、進捗の可視化と品質保証を両立できます。

**9.2 実装チェックリスト → 詳細な作業管理**

```yaml
implementation_checklist:
  # 事前準備
  prerequisites:
    - name: "AWS Organizations設定確認"
      status: "required"
      owner: "IT管理者"
      estimated_hours: 8
    - name: "既存IAMユーザー・ロール調査"
      status: "required" 
      owner: "セキュリティチーム"
      estimated_hours: 40
    - name: "コンプライアンス要件整理"
      status: "required"
      owner: "コンプライアンス"
      estimated_hours: 16
    - name: "既存権限の文書化"
      status: "required"
      owner: "各事業部門"
      estimated_hours: 80

  # IAM Identity Center設定
  identity_center_setup:
    - name: "Identity Center有効化"
      status: "required"
      owner: "IT管理者"
      estimated_hours: 4
      dependencies: ["Organizations設定確認"]
    - name: "外部IDプロバイダー統合"
      status: "required"
      owner: "IT管理者"
      estimated_hours: 16
      dependencies: ["Identity Center有効化"]
    - name: "基本Permission Set作成"
      status: "required"
      owner: "セキュリティチーム"
      estimated_hours: 24
      dependencies: ["外部IDプロバイダー統合"]
    - name: "ユーザー・グループマッピング"
      status: "required"
      owner: "HR・IT管理者"
      estimated_hours: 32
      dependencies: ["基本Permission Set作成"]

  estimated_total_effort:
    total_hours: 592
    total_weeks: "約15週間（複数人並行作業想定）"
    critical_path: "既存権限調査 → Permission Set作成 → ユーザーマッピング → テスト"
```

実装チェックリストは、複雑なマルチアカウント権限管理プロジェクトを体系的に管理し、作業の漏れや遅延を防止します。事前準備段階では、現状調査と要件整理により、実装の基盤を確立します。既存IAMユーザー・ロールの詳細調査により、移行時の影響を事前に把握し、適切な移行戦略を策定できます。依存関係の明確化により、作業の順序を最適化し、並行作業の可能性を最大化します。工数見積もりにより、リソース計画とスケジュール管理の精度を向上させ、プロジェクトの成功確率を高めます。クリティカルパスの特定により、プロジェクト全体のボトルネックを事前に把握し、適切なリソース配分を実現できます。

## **まとめ**

**主要成果物 → 包括的権限管理システムの確立**

本AWSアカウント・権限設計（基本方針）は、TechNova社の120アカウント構成における包括的な権限管理戦略を定義しています。

- **ゼロトラスト権限モデルの確立** → 全てのアクセスを検証し、継続的な信頼度評価による動的なセキュリティ境界を構築
- **IAM Identity Centerによる統合認証基盤** → 外部IDプロバイダーとの統合により、シームレスで安全な認証体験を提供
- **最小権限原則の徹底実装** → JITアクセスとABACにより、必要最小限の権限のみを動的に付与
- **職務分離による不正防止機能** → 開発・運用・監査の明確な分離により、内部不正リスクを最小化
- **コンプライアンス自動化システム** → SOC2・ISO27001・PCI DSSへの継続的準拠を自動監視
- **緊急時アクセス管理機能** → Break Glassプロセスによる迅速な障害対応と厳格な監査証跡
- **包括的監視・ログシステム** → リアルタイム脅威検出と自動化された対応により、セキュリティ運用を効率化

**事業部門別アカウント構成との統合 → 物理・論理分離の最適化**

本方針は、既に定義された事業部門別アカウント構成の物理的な120アカウント分離構造に対し、論理的な権限管理レイヤーを提供します。